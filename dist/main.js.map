{
  "version": 3,
  "file": "main.js",
  "sources": [
    "views.js",
    "../bower_components/angular-sanitize/angular-sanitize.js",
    "../bower_components/videogular/videogular.js",
    "../bower_components/videogular-buffering/buffering.js",
    "../bower_components/videogular-controls/controls.js",
    "../bower_components/videogular-overlay-play/overlay-play.js",
    "../bower_components/videogular-poster/poster.js",
    "ui/module.js",
    "ui/hamburger-menu/hamburger-menu.js",
    "ui/video-player/video-player.js",
    "jp-angular-ui.js"
  ],
  "names": [],
  "mappings": "AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACVA,ADWA;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9qBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACn8CA,ADo8CA;ACn8CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACxyBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvBA,ADwBA;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxCA,ADyCA;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "sourcesContent": [
    "define('views',[],{init:function($templateCache){  'use strict';\n\n  $templateCache.put('ui/hamburger-menu/hamburger-menu.html',\n    \"<div class=jp-hamburger-menu><button class=jp-hamburger-menu__button><div class=jp-hamburger-menu__line></div><div class=jp-hamburger-menu__line></div><div class=jp-hamburger-menu__line></div></button></div>\"\n  );\n\n\n  $templateCache.put('ui/video-player/video-player.html',\n    \"<videogular><vg-video vg-src=config.sources vg-native-controls=true></vg-video></videogular>\"\n  );\n}});\n",
    "/**\n * @license AngularJS v1.4.7\n * (c) 2010-2015 Google, Inc. http://angularjs.org\n * License: MIT\n */\n(function(window, angular, undefined) {'use strict';\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *     Any commits to this file should be reviewed with security in mind.  *\n *   Changes to this file can potentially create security vulnerabilities. *\n *          An approval from 2 Core members with history of modifying      *\n *                         this file is required.                          *\n *                                                                         *\n *  Does the change somehow allow for arbitrary javascript to be executed? *\n *    Or allows for someone to change the prototype of built-in objects?   *\n *     Or gives undesired access to variables likes document or window?    *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nvar $sanitizeMinErr = angular.$$minErr('$sanitize');\n\n/**\n * @ngdoc module\n * @name ngSanitize\n * @description\n *\n * # ngSanitize\n *\n * The `ngSanitize` module provides functionality to sanitize HTML.\n *\n *\n * <div doc-module-components=\"ngSanitize\"></div>\n *\n * See {@link ngSanitize.$sanitize `$sanitize`} for usage.\n */\n\n/*\n * HTML Parser By Misko Hevery (misko@hevery.com)\n * based on:  HTML Parser By John Resig (ejohn.org)\n * Original code by Erik Arvidsson, Mozilla Public License\n * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\n *\n * // Use like so:\n * htmlParser(htmlString, {\n *     start: function(tag, attrs, unary) {},\n *     end: function(tag) {},\n *     chars: function(text) {},\n *     comment: function(text) {}\n * });\n *\n */\n\n\n/**\n * @ngdoc service\n * @name $sanitize\n * @kind function\n *\n * @description\n *   The input is sanitized by parsing the HTML into tokens. All safe tokens (from a whitelist) are\n *   then serialized back to properly escaped html string. This means that no unsafe input can make\n *   it into the returned string, however, since our parser is more strict than a typical browser\n *   parser, it's possible that some obscure input, which would be recognized as valid HTML by a\n *   browser, won't make it through the sanitizer. The input may also contain SVG markup.\n *   The whitelist is configured using the functions `aHrefSanitizationWhitelist` and\n *   `imgSrcSanitizationWhitelist` of {@link ng.$compileProvider `$compileProvider`}.\n *\n * @param {string} html HTML input.\n * @returns {string} Sanitized HTML.\n *\n * @example\n   <example module=\"sanitizeExample\" deps=\"angular-sanitize.js\">\n   <file name=\"index.html\">\n     <script>\n         angular.module('sanitizeExample', ['ngSanitize'])\n           .controller('ExampleController', ['$scope', '$sce', function($scope, $sce) {\n             $scope.snippet =\n               '<p style=\"color:blue\">an html\\n' +\n               '<em onmouseover=\"this.textContent=\\'PWN3D!\\'\">click here</em>\\n' +\n               'snippet</p>';\n             $scope.deliberatelyTrustDangerousSnippet = function() {\n               return $sce.trustAsHtml($scope.snippet);\n             };\n           }]);\n     </script>\n     <div ng-controller=\"ExampleController\">\n        Snippet: <textarea ng-model=\"snippet\" cols=\"60\" rows=\"3\"></textarea>\n       <table>\n         <tr>\n           <td>Directive</td>\n           <td>How</td>\n           <td>Source</td>\n           <td>Rendered</td>\n         </tr>\n         <tr id=\"bind-html-with-sanitize\">\n           <td>ng-bind-html</td>\n           <td>Automatically uses $sanitize</td>\n           <td><pre>&lt;div ng-bind-html=\"snippet\"&gt;<br/>&lt;/div&gt;</pre></td>\n           <td><div ng-bind-html=\"snippet\"></div></td>\n         </tr>\n         <tr id=\"bind-html-with-trust\">\n           <td>ng-bind-html</td>\n           <td>Bypass $sanitize by explicitly trusting the dangerous value</td>\n           <td>\n           <pre>&lt;div ng-bind-html=\"deliberatelyTrustDangerousSnippet()\"&gt;\n&lt;/div&gt;</pre>\n           </td>\n           <td><div ng-bind-html=\"deliberatelyTrustDangerousSnippet()\"></div></td>\n         </tr>\n         <tr id=\"bind-default\">\n           <td>ng-bind</td>\n           <td>Automatically escapes</td>\n           <td><pre>&lt;div ng-bind=\"snippet\"&gt;<br/>&lt;/div&gt;</pre></td>\n           <td><div ng-bind=\"snippet\"></div></td>\n         </tr>\n       </table>\n       </div>\n   </file>\n   <file name=\"protractor.js\" type=\"protractor\">\n     it('should sanitize the html snippet by default', function() {\n       expect(element(by.css('#bind-html-with-sanitize div')).getInnerHtml()).\n         toBe('<p>an html\\n<em>click here</em>\\nsnippet</p>');\n     });\n\n     it('should inline raw snippet if bound to a trusted value', function() {\n       expect(element(by.css('#bind-html-with-trust div')).getInnerHtml()).\n         toBe(\"<p style=\\\"color:blue\\\">an html\\n\" +\n              \"<em onmouseover=\\\"this.textContent='PWN3D!'\\\">click here</em>\\n\" +\n              \"snippet</p>\");\n     });\n\n     it('should escape snippet without any filter', function() {\n       expect(element(by.css('#bind-default div')).getInnerHtml()).\n         toBe(\"&lt;p style=\\\"color:blue\\\"&gt;an html\\n\" +\n              \"&lt;em onmouseover=\\\"this.textContent='PWN3D!'\\\"&gt;click here&lt;/em&gt;\\n\" +\n              \"snippet&lt;/p&gt;\");\n     });\n\n     it('should update', function() {\n       element(by.model('snippet')).clear();\n       element(by.model('snippet')).sendKeys('new <b onclick=\"alert(1)\">text</b>');\n       expect(element(by.css('#bind-html-with-sanitize div')).getInnerHtml()).\n         toBe('new <b>text</b>');\n       expect(element(by.css('#bind-html-with-trust div')).getInnerHtml()).toBe(\n         'new <b onclick=\"alert(1)\">text</b>');\n       expect(element(by.css('#bind-default div')).getInnerHtml()).toBe(\n         \"new &lt;b onclick=\\\"alert(1)\\\"&gt;text&lt;/b&gt;\");\n     });\n   </file>\n   </example>\n */\nfunction $SanitizeProvider() {\n  this.$get = ['$$sanitizeUri', function($$sanitizeUri) {\n    return function(html) {\n      var buf = [];\n      htmlParser(html, htmlSanitizeWriter(buf, function(uri, isImage) {\n        return !/^unsafe/.test($$sanitizeUri(uri, isImage));\n      }));\n      return buf.join('');\n    };\n  }];\n}\n\nfunction sanitizeText(chars) {\n  var buf = [];\n  var writer = htmlSanitizeWriter(buf, angular.noop);\n  writer.chars(chars);\n  return buf.join('');\n}\n\n\n// Regular Expressions for parsing tags and attributes\nvar START_TAG_REGEXP =\n       /^<((?:[a-zA-Z])[\\w:-]*)((?:\\s+[\\w:-]+(?:\\s*=\\s*(?:(?:\"[^\"]*\")|(?:'[^']*')|[^>\\s]+))?)*)\\s*(\\/?)\\s*(>?)/,\n  END_TAG_REGEXP = /^<\\/\\s*([\\w:-]+)[^>]*>/,\n  ATTR_REGEXP = /([\\w:-]+)(?:\\s*=\\s*(?:(?:\"((?:[^\"])*)\")|(?:'((?:[^'])*)')|([^>\\s]+)))?/g,\n  BEGIN_TAG_REGEXP = /^</,\n  BEGING_END_TAGE_REGEXP = /^<\\//,\n  COMMENT_REGEXP = /<!--(.*?)-->/g,\n  DOCTYPE_REGEXP = /<!DOCTYPE([^>]*?)>/i,\n  CDATA_REGEXP = /<!\\[CDATA\\[(.*?)]]>/g,\n  SURROGATE_PAIR_REGEXP = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g,\n  // Match everything outside of normal chars and \" (quote character)\n  NON_ALPHANUMERIC_REGEXP = /([^\\#-~| |!])/g;\n\n\n// Good source of info about elements and attributes\n// http://dev.w3.org/html5/spec/Overview.html#semantics\n// http://simon.html5.org/html-elements\n\n// Safe Void Elements - HTML5\n// http://dev.w3.org/html5/spec/Overview.html#void-elements\nvar voidElements = makeMap(\"area,br,col,hr,img,wbr\");\n\n// Elements that you can, intentionally, leave open (and which close themselves)\n// http://dev.w3.org/html5/spec/Overview.html#optional-tags\nvar optionalEndTagBlockElements = makeMap(\"colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr\"),\n    optionalEndTagInlineElements = makeMap(\"rp,rt\"),\n    optionalEndTagElements = angular.extend({},\n                                            optionalEndTagInlineElements,\n                                            optionalEndTagBlockElements);\n\n// Safe Block Elements - HTML5\nvar blockElements = angular.extend({}, optionalEndTagBlockElements, makeMap(\"address,article,\" +\n        \"aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,\" +\n        \"h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,script,section,table,ul\"));\n\n// Inline Elements - HTML5\nvar inlineElements = angular.extend({}, optionalEndTagInlineElements, makeMap(\"a,abbr,acronym,b,\" +\n        \"bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s,\" +\n        \"samp,small,span,strike,strong,sub,sup,time,tt,u,var\"));\n\n// SVG Elements\n// https://wiki.whatwg.org/wiki/Sanitization_rules#svg_Elements\n// Note: the elements animate,animateColor,animateMotion,animateTransform,set are intentionally omitted.\n// They can potentially allow for arbitrary javascript to be executed. See #11290\nvar svgElements = makeMap(\"circle,defs,desc,ellipse,font-face,font-face-name,font-face-src,g,glyph,\" +\n        \"hkern,image,linearGradient,line,marker,metadata,missing-glyph,mpath,path,polygon,polyline,\" +\n        \"radialGradient,rect,stop,svg,switch,text,title,tspan,use\");\n\n// Special Elements (can contain anything)\nvar specialElements = makeMap(\"script,style\");\n\nvar validElements = angular.extend({},\n                                   voidElements,\n                                   blockElements,\n                                   inlineElements,\n                                   optionalEndTagElements,\n                                   svgElements);\n\n//Attributes that have href and hence need to be sanitized\nvar uriAttrs = makeMap(\"background,cite,href,longdesc,src,usemap,xlink:href\");\n\nvar htmlAttrs = makeMap('abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,' +\n    'color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,' +\n    'ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,' +\n    'scope,scrolling,shape,size,span,start,summary,tabindex,target,title,type,' +\n    'valign,value,vspace,width');\n\n// SVG attributes (without \"id\" and \"name\" attributes)\n// https://wiki.whatwg.org/wiki/Sanitization_rules#svg_Attributes\nvar svgAttrs = makeMap('accent-height,accumulate,additive,alphabetic,arabic-form,ascent,' +\n    'baseProfile,bbox,begin,by,calcMode,cap-height,class,color,color-rendering,content,' +\n    'cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,font-size,font-stretch,' +\n    'font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,gradientUnits,hanging,' +\n    'height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,keySplines,keyTimes,lang,' +\n    'marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mathematical,' +\n    'max,min,offset,opacity,orient,origin,overline-position,overline-thickness,panose-1,' +\n    'path,pathLength,points,preserveAspectRatio,r,refX,refY,repeatCount,repeatDur,' +\n    'requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,stemv,stop-color,' +\n    'stop-opacity,strikethrough-position,strikethrough-thickness,stroke,stroke-dasharray,' +\n    'stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,' +\n    'stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,underline-position,' +\n    'underline-thickness,unicode,unicode-range,units-per-em,values,version,viewBox,visibility,' +\n    'width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,xlink:show,xlink:title,' +\n    'xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,zoomAndPan', true);\n\nvar validAttrs = angular.extend({},\n                                uriAttrs,\n                                svgAttrs,\n                                htmlAttrs);\n\nfunction makeMap(str, lowercaseKeys) {\n  var obj = {}, items = str.split(','), i;\n  for (i = 0; i < items.length; i++) {\n    obj[lowercaseKeys ? angular.lowercase(items[i]) : items[i]] = true;\n  }\n  return obj;\n}\n\n\n/**\n * @example\n * htmlParser(htmlString, {\n *     start: function(tag, attrs, unary) {},\n *     end: function(tag) {},\n *     chars: function(text) {},\n *     comment: function(text) {}\n * });\n *\n * @param {string} html string\n * @param {object} handler\n */\nfunction htmlParser(html, handler) {\n  if (typeof html !== 'string') {\n    if (html === null || typeof html === 'undefined') {\n      html = '';\n    } else {\n      html = '' + html;\n    }\n  }\n  var index, chars, match, stack = [], last = html, text;\n  stack.last = function() { return stack[stack.length - 1]; };\n\n  while (html) {\n    text = '';\n    chars = true;\n\n    // Make sure we're not in a script or style element\n    if (!stack.last() || !specialElements[stack.last()]) {\n\n      // Comment\n      if (html.indexOf(\"<!--\") === 0) {\n        // comments containing -- are not allowed unless they terminate the comment\n        index = html.indexOf(\"--\", 4);\n\n        if (index >= 0 && html.lastIndexOf(\"-->\", index) === index) {\n          if (handler.comment) handler.comment(html.substring(4, index));\n          html = html.substring(index + 3);\n          chars = false;\n        }\n      // DOCTYPE\n      } else if (DOCTYPE_REGEXP.test(html)) {\n        match = html.match(DOCTYPE_REGEXP);\n\n        if (match) {\n          html = html.replace(match[0], '');\n          chars = false;\n        }\n      // end tag\n      } else if (BEGING_END_TAGE_REGEXP.test(html)) {\n        match = html.match(END_TAG_REGEXP);\n\n        if (match) {\n          html = html.substring(match[0].length);\n          match[0].replace(END_TAG_REGEXP, parseEndTag);\n          chars = false;\n        }\n\n      // start tag\n      } else if (BEGIN_TAG_REGEXP.test(html)) {\n        match = html.match(START_TAG_REGEXP);\n\n        if (match) {\n          // We only have a valid start-tag if there is a '>'.\n          if (match[4]) {\n            html = html.substring(match[0].length);\n            match[0].replace(START_TAG_REGEXP, parseStartTag);\n          }\n          chars = false;\n        } else {\n          // no ending tag found --- this piece should be encoded as an entity.\n          text += '<';\n          html = html.substring(1);\n        }\n      }\n\n      if (chars) {\n        index = html.indexOf(\"<\");\n\n        text += index < 0 ? html : html.substring(0, index);\n        html = index < 0 ? \"\" : html.substring(index);\n\n        if (handler.chars) handler.chars(decodeEntities(text));\n      }\n\n    } else {\n      // IE versions 9 and 10 do not understand the regex '[^]', so using a workaround with [\\W\\w].\n      html = html.replace(new RegExp(\"([\\\\W\\\\w]*)<\\\\s*\\\\/\\\\s*\" + stack.last() + \"[^>]*>\", 'i'),\n        function(all, text) {\n          text = text.replace(COMMENT_REGEXP, \"$1\").replace(CDATA_REGEXP, \"$1\");\n\n          if (handler.chars) handler.chars(decodeEntities(text));\n\n          return \"\";\n      });\n\n      parseEndTag(\"\", stack.last());\n    }\n\n    if (html == last) {\n      throw $sanitizeMinErr('badparse', \"The sanitizer was unable to parse the following block \" +\n                                        \"of html: {0}\", html);\n    }\n    last = html;\n  }\n\n  // Clean up any remaining tags\n  parseEndTag();\n\n  function parseStartTag(tag, tagName, rest, unary) {\n    tagName = angular.lowercase(tagName);\n    if (blockElements[tagName]) {\n      while (stack.last() && inlineElements[stack.last()]) {\n        parseEndTag(\"\", stack.last());\n      }\n    }\n\n    if (optionalEndTagElements[tagName] && stack.last() == tagName) {\n      parseEndTag(\"\", tagName);\n    }\n\n    unary = voidElements[tagName] || !!unary;\n\n    if (!unary) {\n      stack.push(tagName);\n    }\n\n    var attrs = {};\n\n    rest.replace(ATTR_REGEXP,\n      function(match, name, doubleQuotedValue, singleQuotedValue, unquotedValue) {\n        var value = doubleQuotedValue\n          || singleQuotedValue\n          || unquotedValue\n          || '';\n\n        attrs[name] = decodeEntities(value);\n    });\n    if (handler.start) handler.start(tagName, attrs, unary);\n  }\n\n  function parseEndTag(tag, tagName) {\n    var pos = 0, i;\n    tagName = angular.lowercase(tagName);\n    if (tagName) {\n      // Find the closest opened tag of the same type\n      for (pos = stack.length - 1; pos >= 0; pos--) {\n        if (stack[pos] == tagName) break;\n      }\n    }\n\n    if (pos >= 0) {\n      // Close all the open elements, up the stack\n      for (i = stack.length - 1; i >= pos; i--)\n        if (handler.end) handler.end(stack[i]);\n\n      // Remove the open elements from the stack\n      stack.length = pos;\n    }\n  }\n}\n\nvar hiddenPre=document.createElement(\"pre\");\n/**\n * decodes all entities into regular string\n * @param value\n * @returns {string} A string with decoded entities.\n */\nfunction decodeEntities(value) {\n  if (!value) { return ''; }\n\n  hiddenPre.innerHTML = value.replace(/</g,\"&lt;\");\n  // innerText depends on styling as it doesn't display hidden elements.\n  // Therefore, it's better to use textContent not to cause unnecessary reflows.\n  return hiddenPre.textContent;\n}\n\n/**\n * Escapes all potentially dangerous characters, so that the\n * resulting string can be safely inserted into attribute or\n * element text.\n * @param value\n * @returns {string} escaped text\n */\nfunction encodeEntities(value) {\n  return value.\n    replace(/&/g, '&amp;').\n    replace(SURROGATE_PAIR_REGEXP, function(value) {\n      var hi = value.charCodeAt(0);\n      var low = value.charCodeAt(1);\n      return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';\n    }).\n    replace(NON_ALPHANUMERIC_REGEXP, function(value) {\n      return '&#' + value.charCodeAt(0) + ';';\n    }).\n    replace(/</g, '&lt;').\n    replace(/>/g, '&gt;');\n}\n\n/**\n * create an HTML/XML writer which writes to buffer\n * @param {Array} buf use buf.jain('') to get out sanitized html string\n * @returns {object} in the form of {\n *     start: function(tag, attrs, unary) {},\n *     end: function(tag) {},\n *     chars: function(text) {},\n *     comment: function(text) {}\n * }\n */\nfunction htmlSanitizeWriter(buf, uriValidator) {\n  var ignore = false;\n  var out = angular.bind(buf, buf.push);\n  return {\n    start: function(tag, attrs, unary) {\n      tag = angular.lowercase(tag);\n      if (!ignore && specialElements[tag]) {\n        ignore = tag;\n      }\n      if (!ignore && validElements[tag] === true) {\n        out('<');\n        out(tag);\n        angular.forEach(attrs, function(value, key) {\n          var lkey=angular.lowercase(key);\n          var isImage = (tag === 'img' && lkey === 'src') || (lkey === 'background');\n          if (validAttrs[lkey] === true &&\n            (uriAttrs[lkey] !== true || uriValidator(value, isImage))) {\n            out(' ');\n            out(key);\n            out('=\"');\n            out(encodeEntities(value));\n            out('\"');\n          }\n        });\n        out(unary ? '/>' : '>');\n      }\n    },\n    end: function(tag) {\n        tag = angular.lowercase(tag);\n        if (!ignore && validElements[tag] === true) {\n          out('</');\n          out(tag);\n          out('>');\n        }\n        if (tag == ignore) {\n          ignore = false;\n        }\n      },\n    chars: function(chars) {\n        if (!ignore) {\n          out(encodeEntities(chars));\n        }\n      }\n  };\n}\n\n\n// define ngSanitize module and register $sanitize service\nangular.module('ngSanitize', []).provider('$sanitize', $SanitizeProvider);\n\n/* global sanitizeText: false */\n\n/**\n * @ngdoc filter\n * @name linky\n * @kind function\n *\n * @description\n * Finds links in text input and turns them into html links. Supports http/https/ftp/mailto and\n * plain email address links.\n *\n * Requires the {@link ngSanitize `ngSanitize`} module to be installed.\n *\n * @param {string} text Input text.\n * @param {string} target Window (_blank|_self|_parent|_top) or named frame to open links in.\n * @returns {string} Html-linkified text.\n *\n * @usage\n   <span ng-bind-html=\"linky_expression | linky\"></span>\n *\n * @example\n   <example module=\"linkyExample\" deps=\"angular-sanitize.js\">\n     <file name=\"index.html\">\n       <script>\n         angular.module('linkyExample', ['ngSanitize'])\n           .controller('ExampleController', ['$scope', function($scope) {\n             $scope.snippet =\n               'Pretty text with some links:\\n'+\n               'http://angularjs.org/,\\n'+\n               'mailto:us@somewhere.org,\\n'+\n               'another@somewhere.org,\\n'+\n               'and one more: ftp://127.0.0.1/.';\n             $scope.snippetWithTarget = 'http://angularjs.org/';\n           }]);\n       </script>\n       <div ng-controller=\"ExampleController\">\n       Snippet: <textarea ng-model=\"snippet\" cols=\"60\" rows=\"3\"></textarea>\n       <table>\n         <tr>\n           <td>Filter</td>\n           <td>Source</td>\n           <td>Rendered</td>\n         </tr>\n         <tr id=\"linky-filter\">\n           <td>linky filter</td>\n           <td>\n             <pre>&lt;div ng-bind-html=\"snippet | linky\"&gt;<br>&lt;/div&gt;</pre>\n           </td>\n           <td>\n             <div ng-bind-html=\"snippet | linky\"></div>\n           </td>\n         </tr>\n         <tr id=\"linky-target\">\n          <td>linky target</td>\n          <td>\n            <pre>&lt;div ng-bind-html=\"snippetWithTarget | linky:'_blank'\"&gt;<br>&lt;/div&gt;</pre>\n          </td>\n          <td>\n            <div ng-bind-html=\"snippetWithTarget | linky:'_blank'\"></div>\n          </td>\n         </tr>\n         <tr id=\"escaped-html\">\n           <td>no filter</td>\n           <td><pre>&lt;div ng-bind=\"snippet\"&gt;<br>&lt;/div&gt;</pre></td>\n           <td><div ng-bind=\"snippet\"></div></td>\n         </tr>\n       </table>\n     </file>\n     <file name=\"protractor.js\" type=\"protractor\">\n       it('should linkify the snippet with urls', function() {\n         expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).\n             toBe('Pretty text with some links: http://angularjs.org/, us@somewhere.org, ' +\n                  'another@somewhere.org, and one more: ftp://127.0.0.1/.');\n         expect(element.all(by.css('#linky-filter a')).count()).toEqual(4);\n       });\n\n       it('should not linkify snippet without the linky filter', function() {\n         expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText()).\n             toBe('Pretty text with some links: http://angularjs.org/, mailto:us@somewhere.org, ' +\n                  'another@somewhere.org, and one more: ftp://127.0.0.1/.');\n         expect(element.all(by.css('#escaped-html a')).count()).toEqual(0);\n       });\n\n       it('should update', function() {\n         element(by.model('snippet')).clear();\n         element(by.model('snippet')).sendKeys('new http://link.');\n         expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).\n             toBe('new http://link.');\n         expect(element.all(by.css('#linky-filter a')).count()).toEqual(1);\n         expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText())\n             .toBe('new http://link.');\n       });\n\n       it('should work with the target property', function() {\n        expect(element(by.id('linky-target')).\n            element(by.binding(\"snippetWithTarget | linky:'_blank'\")).getText()).\n            toBe('http://angularjs.org/');\n        expect(element(by.css('#linky-target a')).getAttribute('target')).toEqual('_blank');\n       });\n     </file>\n   </example>\n */\nangular.module('ngSanitize').filter('linky', ['$sanitize', function($sanitize) {\n  var LINKY_URL_REGEXP =\n        /((ftp|https?):\\/\\/|(www\\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\\S*[^\\s.;,(){}<>\"\\u201d\\u2019]/i,\n      MAILTO_REGEXP = /^mailto:/i;\n\n  return function(text, target) {\n    if (!text) return text;\n    var match;\n    var raw = text;\n    var html = [];\n    var url;\n    var i;\n    while ((match = raw.match(LINKY_URL_REGEXP))) {\n      // We can not end in these as they are sometimes found at the end of the sentence\n      url = match[0];\n      // if we did not match ftp/http/www/mailto then assume mailto\n      if (!match[2] && !match[4]) {\n        url = (match[3] ? 'http://' : 'mailto:') + url;\n      }\n      i = match.index;\n      addText(raw.substr(0, i));\n      addLink(url, match[0].replace(MAILTO_REGEXP, ''));\n      raw = raw.substring(i + match[0].length);\n    }\n    addText(raw);\n    return $sanitize(html.join(''));\n\n    function addText(text) {\n      if (!text) {\n        return;\n      }\n      html.push(sanitizeText(text));\n    }\n\n    function addLink(url, text) {\n      html.push('<a ');\n      if (angular.isDefined(target)) {\n        html.push('target=\"',\n                  target,\n                  '\" ');\n      }\n      html.push('href=\"',\n                url.replace(/\"/g, '&quot;'),\n                '\">');\n      addText(text);\n      html.push('</a>');\n    }\n  };\n}]);\n\n\n})(window, window.angular);\n\ndefine(\"angular-sanitize\", function(){});\n\n",
    "/**\n * @license videogular v1.3.2 http://videogular.com\n * Two Fucking Developers http://twofuckingdevelopers.com\n * License: MIT\n */\n\"use strict\";\nangular.module(\"com.2fdevs.videogular\", [\"ngSanitize\"])\n    .run(\n    [\"$templateCache\", function ($templateCache) {\n        $templateCache.put(\"vg-templates/vg-media-video\", \"<video></video>\");\n        $templateCache.put(\"vg-templates/vg-media-audio\", \"<audio></audio>\");\n\n        // Support for browsers that doesn't have .bind()\n        if (!Function.prototype.bind) {\n            Function.prototype.bind = function (oThis) {\n                if (typeof this !== 'function') {\n                    // closest thing possible to the ECMAScript 5\n                    // internal IsCallable function\n                    throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');\n                }\n\n                var aArgs = Array.prototype.slice.call(arguments, 1),\n                    fToBind = this,\n                    fNOP = function () {\n                    },\n                    fBound = function () {\n                        return fToBind.apply(this instanceof fNOP\n                                ? this\n                                : oThis,\n                            aArgs.concat(Array.prototype.slice.call(arguments)));\n                    };\n\n                fNOP.prototype = this.prototype;\n                fBound.prototype = new fNOP();\n\n                return fBound;\n            };\n        }\n    }]\n);\n\n/**\n * @ngdoc service\n * @name com.2fdevs.videogular.constant:VG_STATES\n *\n * @description\n * Possible video states:\n *  - VG_STATES.PLAY: \"play\"\n *  - VG_STATES.PAUSE: \"pause\"\n *  - VG_STATES.STOP: \"stop\"\n **/\n/**\n * @ngdoc service\n * @name com.2fdevs.videogular.constant:VG_VOLUME_KEY\n *\n * @description localStorage key name for persistent video play volume on a domain.\n **/\n\"use strict\";\nangular.module(\"com.2fdevs.videogular\")\n    .constant(\"VG_STATES\", {\n        PLAY: \"play\",\n        PAUSE: \"pause\",\n        STOP: \"stop\"\n    })\n    .constant(\"VG_VOLUME_KEY\", \"videogularVolume\");\n\n\"use strict\";\n/**\n * @ngdoc controller\n * @name com.2fdevs.videogular.controller:vgController\n * @description\n * Videogular controller.\n * This controller offers a public API:\n *\n * Methods\n * - play(): Plays media.\n * - pause(): Pause media.\n * - stop(): Stops media.\n * - playPause(): Toggles play and pause.\n * - seekTime(value, byPercent): Seeks to a specified time position. Param value must be an integer representing the target position in seconds or a percentage. By default seekTime seeks by seconds, if you want to seek by percentage just pass byPercent to true.\n * - setVolume(volume): Sets volume. Param volume must be an integer with a value between 0 and 1.\n * - setPlayback(playback): Sets playback. Param plaback must be an integer with a value between 0 and 2.\n * - setState(state): Sets a new state. Param state mus be an string with 'play', 'pause' or 'stop'. This method only changes the state of the player, but doesn't plays, pauses or stops the media file.\n * - toggleFullScreen(): Toggles between fullscreen and normal mode.\n * - updateTheme(css-url): Removes previous CSS theme and sets a new one.\n * - clearMedia(): Cleans the current media file.\n * - changeSource(array): Updates current media source. Param `array` must be an array of media source objects.\n * A media source is an object with two properties `src` and `type`. The `src` property must contains a trustful url resource.\n * <pre>{src: $sce.trustAsResourceUrl(\"http://static.videogular.com/assets/videos/videogular.mp4\"), type: \"video/mp4\"}</pre>\n *\n * Properties\n * - config: String with a url to JSON config file.\n * - isReady: Boolean value with current player initialization state.\n * - isBuffering: Boolean value to know if player is buffering media.\n * - isCompleted: Boolean value to know if current media file has been completed.\n * - isLive: Boolean value to know if current media file is a Live Streaming.\n * - playsInline: Boolean value to know if Videogular is using inline playing or not.\n * - nativeFullscreen: Boolean value to know if Videogular if fullscreen mode will use native mode or emulated mode.\n * - mediaElement: Reference to video/audio object.\n * - videogularElement: Reference to videogular tag.\n * - sources: Array with current sources.\n * - tracks: Array with current tracks.\n * - cuePoints: Object containing a list of timelines with cue points. Each property in the object represents a timeline, which is an Array of objects with the next definition:\n * <pre>{\n *    timeLapse:{\n *      start: 0,\n *      end: 10\n *    },\n *    onEnter: callback(currentTime, timeLapse, params),\n *    onLeave: callback(currentTime, timeLapse, params),\n *    onUpdate: callback(currentTime, timeLapse, params),\n *    onComplete: callback(currentTime, timeLapse, params),\n *    params: {\n *      // Custom object with desired structure and data\n *    }\n * }</pre>\n *\n *    * **timeLapse:** Object with start and end properties to define in seconds when this timeline is active.\\n\n *    * **onEnter:** Callback function that will be called when progress reaches a cue point or being outside a cue point user seeks to a cue point manually.\n *    * **onLeave:** Callback function that will be called when user seeks and the new time doesn't reach to the timeLapse.start property.\n *    * **onUpdate:** Callback function that will be called when the progress is in the middle of timeLapse.start and timeLapse.end.\n *    * **onComplete:** Callback function that will be called when the progress is bigger than timeLapse.end.\n *    * **params:** Custom object with data to pass to the callbacks.\n *\n * - isFullScreen: Boolean value to know if we’re in fullscreen mode.\n * - currentState: String value with “play”, “pause” or “stop”.\n * - currentTime: Number value with current media time progress.\n * - totalTime: Number value with total media time.\n * - timeLeft: Number value with current media time left.\n * - volume: Number value with current volume between 0 and 1.\n * - playback: Number value with current playback between 0 and 2.\n * - bufferEnd: Number value with latest buffer point in milliseconds.\n * - buffered: Array of TimeRanges objects that represents current buffer state.\n *\n */\nangular.module(\"com.2fdevs.videogular\")\n    .controller(\"vgController\",\n    ['$scope', '$window', 'vgConfigLoader', 'vgFullscreen', 'VG_UTILS', 'VG_STATES', 'VG_VOLUME_KEY', function ($scope, $window, vgConfigLoader, vgFullscreen, VG_UTILS, VG_STATES, VG_VOLUME_KEY) {\n        var currentTheme = null;\n        var isFullScreenPressed = false;\n        var isMetaDataLoaded = false;\n\n        // PUBLIC $API\n        this.videogularElement = null;\n\n        this.clearMedia = function () {\n            this.mediaElement[0].src = '';\n        };\n\n        this.onRouteChange = function() {\n            if (this.clearMediaOnNavigate === undefined || this.clearMediaOnNavigate === true) {\n                this.clearMedia();\n            }\n        };\n\n        this.onCanPlay = function (evt) {\n            this.isBuffering = false;\n            $scope.$apply($scope.vgCanPlay({$event: evt}));\n        };\n\n        this.onVideoReady = function () {\n            this.isReady = true;\n            this.autoPlay = $scope.vgAutoPlay;\n            this.playsInline = $scope.vgPlaysInline;\n            this.nativeFullscreen = $scope.vgNativeFullscreen || true;\n            this.cuePoints = $scope.vgCuePoints;\n            this.clearMediaOnNavigate = $scope.vgClearMediaOnNavigate || true;\n            this.currentState = VG_STATES.STOP;\n\n            isMetaDataLoaded = true;\n\n            //Set media volume from localStorage if available\n            if (VG_UTILS.supportsLocalStorage()) {\n                //Default to 100% volume if local storage setting does not exist.\n                this.setVolume(parseFloat($window.localStorage.getItem(VG_VOLUME_KEY) || '1'));\n            }\n\n            if ($scope.vgConfig) {\n                vgConfigLoader.loadConfig($scope.vgConfig).then(\n                    this.onLoadConfig.bind(this)\n                );\n            }\n            else {\n                $scope.vgPlayerReady({$API: this});\n            }\n        };\n\n        this.onLoadConfig = function (config) {\n            this.config = config;\n\n            $scope.vgTheme = this.config.theme;\n            $scope.vgAutoPlay = this.config.autoPlay;\n            $scope.vgPlaysInline = this.config.playsInline;\n            $scope.vgNativeFullscreen = this.config.nativeFullscreen;\n            $scope.vgCuePoints = this.config.cuePoints;\n            $scope.vgClearMediaOnNavigate = this.config.clearMediaOnNavigate;\n\n            $scope.vgPlayerReady({$API: this});\n        };\n\n        this.onLoadMetaData = function (evt) {\n            this.isBuffering = false;\n            this.onUpdateTime(evt);\n        };\n\n        this.onProgress = function (event) {\n            if (event.target.buffered.length) {\n                this.buffered = event.target.buffered;\n                this.bufferEnd = 1000 * event.target.buffered.end(event.target.buffered.length - 1);\n            }\n\n            $scope.$apply();\n        };\n\n        this.onUpdateTime = function (event) {\n            this.currentTime = 1000 * event.target.currentTime;\n\n            if (event.target.buffered.length) {\n                this.buffered = event.target.buffered;\n                this.bufferEnd = 1000 * event.target.buffered.end(event.target.buffered.length - 1);\n            }\n\n            if (event.target.duration != Infinity) {\n                this.totalTime = 1000 * event.target.duration;\n                this.timeLeft = 1000 * (event.target.duration - event.target.currentTime);\n                this.isLive = false;\n            }\n            else {\n                // It's a live streaming without and end\n                this.isLive = true;\n            }\n\n            if (this.cuePoints) {\n                this.checkCuePoints(event.target.currentTime);\n            }\n\n            $scope.vgUpdateTime({$currentTime: event.target.currentTime, $duration: event.target.duration});\n\n            $scope.$apply();\n        };\n\n        this.checkCuePoints = function checkCuePoints(currentTime) {\n            for (var tl in this.cuePoints) {\n                for (var i = 0, l = this.cuePoints[tl].length; i < l; i++) {\n                    var cp = this.cuePoints[tl][i];\n                    var currentSecond = parseInt(currentTime, 10);\n                    var start = parseInt(cp.timeLapse.start, 10);\n\n                    // If timeLapse.end is not defined we set it as 1 second length\n                    if (!cp.timeLapse.end) cp.timeLapse.end = cp.timeLapse.start + 1;\n\n                    if (currentTime < cp.timeLapse.end) cp.$$isCompleted = false;\n\n                    // Fire the onEnter event once reach to the cue point\n                    if(!cp.$$isDirty && currentSecond === start && (typeof cp.onEnter == 'function')) {\n                        cp.onEnter(currentTime, cp.timeLapse, cp.params);\n                        cp.$$isDirty = true;\n                    }\n\n                    // Check if we've been reached to the cue point\n                    if (currentTime > cp.timeLapse.start) {\n                        // We're in the timelapse\n                        if (currentTime < cp.timeLapse.end) {\n                            // Trigger onUpdate each time we enter here\n                            if (cp.onUpdate) cp.onUpdate(currentTime, cp.timeLapse, cp.params);\n\n                            // Trigger onEnter if we enter on the cue point by manually seeking\n                            if (!cp.$$isDirty && (typeof cp.onEnter === 'function')) {\n                                cp.onEnter(currentTime, cp.timeLapse, cp.params);\n                            }\n                        }\n\n                        // We've been passed the cue point\n                        if (currentTime >= cp.timeLapse.end) {\n                            if (cp.onComplete && !cp.$$isCompleted) {\n                                cp.$$isCompleted = true;\n                                cp.onComplete(currentTime, cp.timeLapse, cp.params);\n                            }\n                        }\n\n                        cp.$$isDirty = true;\n                    }\n                    else {\n                        if (cp.onLeave && cp.$$isDirty) {\n                            cp.onLeave(currentTime, cp.timeLapse, cp.params);\n                        }\n\n                        cp.$$isDirty = false;\n                    }\n                }\n            }\n        };\n\n        this.onPlay = function () {\n            this.setState(VG_STATES.PLAY);\n            $scope.$apply();\n        };\n\n        this.onPause = function () {\n            if (this.mediaElement[0].currentTime == 0) {\n                this.setState(VG_STATES.STOP);\n            }\n            else {\n                this.setState(VG_STATES.PAUSE);\n            }\n\n            $scope.$apply();\n        };\n\n        this.onVolumeChange = function () {\n            this.volume = this.mediaElement[0].volume;\n            $scope.$apply();\n        };\n\n        this.onPlaybackChange = function () {\n            this.playback = this.mediaElement[0].playbackRate;\n            $scope.$apply();\n        };\n\n        this.onSeeking = function (event) {\n            $scope.vgSeeking({$currentTime: event.target.currentTime, $duration: event.target.duration});\n        };\n\n        this.onSeeked = function (event) {\n            $scope.vgSeeked({$currentTime: event.target.currentTime, $duration: event.target.duration});\n        };\n\n        this.seekTime = function (value, byPercent) {\n            var second;\n            if (byPercent) {\n                second = value * this.mediaElement[0].duration / 100;\n                this.mediaElement[0].currentTime = second;\n            }\n            else {\n                second = value;\n                this.mediaElement[0].currentTime = second;\n            }\n\n            this.currentTime = 1000 * second;\n        };\n\n        this.playPause = function () {\n            if (this.mediaElement[0].paused) {\n                this.play();\n            }\n            else {\n                this.pause();\n            }\n        };\n\n        this.setState = function (newState) {\n            if (newState && newState != this.currentState) {\n                $scope.vgUpdateState({$state: newState});\n\n                this.currentState = newState;\n            }\n\n            return this.currentState;\n        };\n\n        this.play = function () {\n            this.mediaElement[0].play();\n            this.setState(VG_STATES.PLAY);\n        };\n\n        this.pause = function () {\n            this.mediaElement[0].pause();\n            this.setState(VG_STATES.PAUSE);\n        };\n\n        this.stop = function () {\n            try {\n                this.mediaElement[0].pause();\n                this.mediaElement[0].currentTime = 0;\n\n                this.currentTime = 0;\n                this.buffered = [];\n                this.bufferEnd = 0;\n                this.setState(VG_STATES.STOP);\n            }\n            catch (e) {\n                return e;\n            }\n        };\n\n        this.toggleFullScreen = function () {\n            // There is no native full screen support or we want to play inline\n            if (!vgFullscreen.isAvailable || !this.nativeFullscreen) {\n                if (this.isFullScreen) {\n                    this.videogularElement.removeClass(\"fullscreen\");\n                    this.videogularElement.css(\"z-index\", \"auto\");\n                }\n                else {\n                    this.videogularElement.addClass(\"fullscreen\");\n                    this.videogularElement.css(\"z-index\", VG_UTILS.getZIndex());\n                }\n\n                this.isFullScreen = !this.isFullScreen;\n            }\n            // Perform native full screen support\n            else {\n                if (this.isFullScreen) {\n                    if (!VG_UTILS.isMobileDevice()) {\n                        vgFullscreen.exit();\n                    }\n                }\n                else {\n                    // On mobile devices we should make fullscreen only the video object\n                    if (VG_UTILS.isMobileDevice()) {\n                        // On iOS we should check if user pressed before fullscreen button\n                        // and also if metadata is loaded\n                        if (VG_UTILS.isiOSDevice()) {\n                            if (isMetaDataLoaded) {\n                                this.enterElementInFullScreen(this.mediaElement[0]);\n                            }\n                            else {\n                                isFullScreenPressed = true;\n                                this.play();\n                            }\n                        }\n                        else {\n                            this.enterElementInFullScreen(this.mediaElement[0]);\n                        }\n                    }\n                    else {\n                        this.enterElementInFullScreen(this.videogularElement[0]);\n                    }\n                }\n            }\n        };\n\n        this.enterElementInFullScreen = function (element) {\n            vgFullscreen.request(element);\n        };\n\n        this.changeSource = function (newValue) {\n            $scope.vgChangeSource({$source: newValue});\n        };\n\n        this.setVolume = function (newVolume) {\n            newVolume = Math.max(Math.min(newVolume, 1), 0);\n            $scope.vgUpdateVolume({$volume: newVolume});\n\n            this.mediaElement[0].volume = newVolume;\n            this.volume = newVolume;\n\n            //Push volume updates to localStorage so that future instances resume volume\n            if (VG_UTILS.supportsLocalStorage()) {\n                //TODO: Improvement: concat key with current page or \"video player id\" to create separate stored volumes.\n                $window.localStorage.setItem(VG_VOLUME_KEY, newVolume.toString());\n            }\n        };\n\n        this.setPlayback = function (newPlayback) {\n            $scope.vgUpdatePlayback({$playBack: newPlayback});\n\n            this.mediaElement[0].playbackRate = newPlayback;\n            this.playback = newPlayback;\n        };\n\n        this.updateTheme = function (value) {\n            var links = document.getElementsByTagName(\"link\");\n            var i;\n            var l;\n\n            // Remove previous theme\n            if (currentTheme) {\n                for (i = 0, l = links.length; i < l; i++) {\n                    if (links[i].outerHTML.indexOf(currentTheme) >= 0) {\n\n                        links[i].parentNode.removeChild(links[i]);\n                        break;\n                    }\n                }\n            }\n\n            if (value) {\n                var headElem = angular.element(document).find(\"head\");\n                var exists = false;\n\n                // Look if theme already exists\n                for (i = 0, l = links.length; i < l; i++) {\n                    exists = (links[i].outerHTML.indexOf(value) >= 0);\n                    if (exists) break;\n                }\n\n                if (!exists) {\n                    headElem.append(\"<link rel='stylesheet' href='\" + value + \"'>\");\n                }\n\n                currentTheme = value;\n            }\n        };\n\n        this.onStartBuffering = function (event) {\n            this.isBuffering = true;\n            $scope.$apply();\n        };\n\n        this.onStartPlaying = function (event) {\n            this.isBuffering = false;\n            $scope.$apply();\n        };\n\n        this.onComplete = function (event) {\n            $scope.vgComplete();\n\n            this.setState(VG_STATES.STOP);\n            this.isCompleted = true;\n            $scope.$apply();\n        };\n\n        this.onVideoError = function (event) {\n            $scope.vgError({$event: event});\n        };\n\n        this.addListeners = function () {\n            this.mediaElement[0].addEventListener(\"canplay\", this.onCanPlay.bind(this), false);\n            this.mediaElement[0].addEventListener(\"loadedmetadata\", this.onLoadMetaData.bind(this), false);\n            this.mediaElement[0].addEventListener(\"waiting\", this.onStartBuffering.bind(this), false);\n            this.mediaElement[0].addEventListener(\"ended\", this.onComplete.bind(this), false);\n            this.mediaElement[0].addEventListener(\"playing\", this.onStartPlaying.bind(this), false);\n            this.mediaElement[0].addEventListener(\"play\", this.onPlay.bind(this), false);\n            this.mediaElement[0].addEventListener(\"pause\", this.onPause.bind(this), false);\n            this.mediaElement[0].addEventListener(\"volumechange\", this.onVolumeChange.bind(this), false);\n            this.mediaElement[0].addEventListener(\"playbackchange\", this.onPlaybackChange.bind(this), false);\n            this.mediaElement[0].addEventListener(\"timeupdate\", this.onUpdateTime.bind(this), false);\n            this.mediaElement[0].addEventListener(\"progress\", this.onProgress.bind(this), false);\n            this.mediaElement[0].addEventListener(\"seeking\", this.onSeeking.bind(this), false);\n            this.mediaElement[0].addEventListener(\"seeked\", this.onSeeked.bind(this), false);\n            this.mediaElement[0].addEventListener(\"error\", this.onVideoError.bind(this), false);\n        };\n\n        this.init = function () {\n            this.isReady = false;\n            this.isCompleted = false;\n            this.buffered = [];\n            this.bufferEnd = 0;\n            this.currentTime = 0;\n            this.totalTime = 0;\n            this.timeLeft = 0;\n            this.isLive = false;\n            this.isFullScreen = false;\n            this.playback = 1;\n            this.isConfig = ($scope.vgConfig != undefined);\n\n            if (vgFullscreen.isAvailable) {\n                this.isFullScreen = vgFullscreen.isFullScreen();\n            }\n\n            this.updateTheme($scope.vgTheme);\n            this.addBindings();\n\n            if (vgFullscreen.isAvailable) {\n                document.addEventListener(vgFullscreen.onchange, this.onFullScreenChange.bind(this));\n            }\n        };\n\n        this.onUpdateTheme = function onUpdateTheme(newValue) {\n            this.updateTheme(newValue);\n        };\n\n        this.onUpdateAutoPlay = function onUpdateAutoPlay(newValue) {\n            if (newValue && !this.autoPlay) {\n                this.autoPlay = newValue;\n                this.play(this);\n            }\n        };\n\n        this.onUpdatePlaysInline = function onUpdatePlaysInline(newValue) {\n            this.playsInline = newValue;\n        };\n\n        this.onUpdateNativeFullscreen = function onUpdateNativeFullscreen(newValue) {\n            if (newValue == undefined) newValue = true;\n\n            this.nativeFullscreen = newValue;\n        };\n\n        this.onUpdateCuePoints = function onUpdateCuePoints(newValue) {\n            this.cuePoints = newValue;\n            this.checkCuePoints(this.currentTime);\n        };\n\n        this.onUpdateClearMediaOnNavigate = function onUpdateClearMediaOnNavigate(newValue) {\n            this.clearMediaOnNavigate = newValue;\n        };\n\n        this.addBindings = function () {\n            $scope.$watch(\"vgTheme\", this.onUpdateTheme.bind(this));\n\n            $scope.$watch(\"vgAutoPlay\", this.onUpdateAutoPlay.bind(this));\n\n            $scope.$watch(\"vgPlaysInline\", this.onUpdatePlaysInline.bind(this));\n\n            $scope.$watch(\"vgNativeFullscreen\", this.onUpdateNativeFullscreen.bind(this));\n\n            $scope.$watch(\"vgCuePoints\", this.onUpdateCuePoints.bind(this));\n\n            $scope.$watch(\"vgClearMediaOnNavigate\", this.onUpdateClearMediaOnNavigate.bind(this));\n        };\n\n        this.onFullScreenChange = function (event) {\n            this.isFullScreen = vgFullscreen.isFullScreen();\n            $scope.$apply();\n        };\n\n        // Empty mediaElement on destroy to avoid that Chrome downloads video even when it's not present\n        $scope.$on('$destroy', this.clearMedia.bind(this));\n\n        // Empty mediaElement when router changes\n        $scope.$on('$routeChangeStart', this.onRouteChange.bind(this));\n\n        this.init();\n    }]\n);\n\n/**\n * @ngdoc directive\n * @name com.2fdevs.videogular.directive:vgCrossorigin\n * @restrict A\n * @description\n * Optional directive for `vg-media` to add or remove a crossorigin policy to the video object. Possible values are: \"anonymous\" and \"use-credentials\".\n * This feature should be enabled if you want to have your subtitles or video files on a different domain than the video player. Additionally you need\n * to add CORS policies to your video and track files to your server to make it work.\n *\n */\n\"use strict\";\nangular.module(\"com.2fdevs.videogular\")\n    .directive(\"vgCrossorigin\",\n    [function () {\n        return {\n            restrict: \"A\",\n            require: \"^videogular\",\n            link: {\n                pre: function (scope, elem, attr, API) {\n                    var crossorigin;\n\n                    scope.setCrossorigin = function setCrossorigin(value) {\n                        if (value) {\n                            API.mediaElement.attr(\"crossorigin\", value);\n                        }\n                        else {\n                            API.mediaElement.removeAttr(\"crossorigin\");\n                        }\n                    };\n\n                    if (API.isConfig) {\n                        scope.$watch(\n                            function () {\n                                return API.config;\n                            },\n                            function () {\n                                if (API.config) {\n                                    scope.setCrossorigin(API.config.crossorigin);\n                                }\n                            }\n                        );\n                    }\n                    else {\n                        scope.$watch(attr.vgCrossorigin, function (newValue, oldValue) {\n                            if ((!crossorigin || newValue != oldValue) && newValue) {\n                                crossorigin = newValue;\n                                scope.setCrossorigin(crossorigin);\n                            }\n                            else {\n                                scope.setCrossorigin();\n                            }\n                        });\n                    }\n                }\n            }\n        }\n    }\n    ]);\n\n/**\n * @ngdoc directive\n * @name com.2fdevs.videogular.directive:vgLoop\n * @restrict A\n * @description\n * Optional directive for `vg-media` to add or remove loop in media files. Possible values are: \"true\" and \"false\"\n *\n */\n\"use strict\";\nangular.module(\"com.2fdevs.videogular\")\n    .directive(\"vgLoop\",\n    [function () {\n        return {\n            restrict: \"A\",\n            require: \"^videogular\",\n            link: {\n                pre: function (scope, elem, attr, API) {\n                    var loop;\n\n                    scope.setLoop = function setLoop(value) {\n                        if (value) {\n                            API.mediaElement.attr(\"loop\", value);\n                        }\n                        else {\n                            API.mediaElement.removeAttr(\"loop\");\n                        }\n                    };\n\n                    if (API.isConfig) {\n                        scope.$watch(\n                            function () {\n                                return API.config;\n                            },\n                            function () {\n                                if (API.config) {\n                                    scope.setLoop(API.config.loop);\n                                }\n                            }\n                        );\n                    }\n                    else {\n                        scope.$watch(attr.vgLoop, function (newValue, oldValue) {\n                            if ((!loop || newValue != oldValue) && newValue) {\n                                loop = newValue;\n                                scope.setLoop(loop);\n                            }\n                            else {\n                                scope.setLoop();\n                            }\n                        });\n                    }\n                }\n            }\n        }\n    }\n    ]);\n\n/**\n * @ngdoc directive\n * @name com.2fdevs.videogular.direcitve:vgMedia\n * @restrict E\n * @description\n * Directive to add a source of videos or audios. This directive will create a &lt;video&gt; or &lt;audio&gt; tag and usually will be above plugin tags.\n *\n * @param {array} vgSrc Bindable array with a list of media sources. A media source is an object with two properties `src` and `type`. The `src` property must contains a trustful url resource.\n * @param {string} vgType String with \"video\" or \"audio\" values to set a <video> or <audio> tag inside <vg-media>.\n * <pre>\n * {\n *    src: $sce.trustAsResourceUrl(\"path/to/video/videogular.mp4\"),\n *    type: \"video/mp4\"\n * }\n * </pre>\n *\n */\n\"use strict\";\nangular.module(\"com.2fdevs.videogular\")\n    .directive(\"vgMedia\",\n    [\"$timeout\", \"VG_UTILS\", \"VG_STATES\", function ($timeout, VG_UTILS, VG_STATES) {\n        return {\n            restrict: \"E\",\n            require: \"^videogular\",\n            templateUrl: function (elem, attrs) {\n                var vgType = attrs.vgType || \"video\";\n                return attrs.vgTemplate || \"vg-templates/vg-media-\" + vgType;\n            },\n            scope: {\n                vgSrc: \"=?\",\n                vgType: \"=?\"\n            },\n            link: function (scope, elem, attrs, API) {\n                var sources;\n\n                // what type of media do we want? defaults to 'video'\n                if (!attrs.vgType || attrs.vgType === \"video\") {\n                    attrs.vgType = \"video\";\n                }\n                else {\n                    attrs.vgType = \"audio\";\n                }\n\n                // FUNCTIONS\n                scope.onChangeSource = function onChangeSource(newValue, oldValue) {\n                    if ((!sources || newValue != oldValue) && newValue) {\n                        sources = newValue;\n\n                        if (API.currentState !== VG_STATES.PLAY) {\n                            API.currentState = VG_STATES.STOP;\n                        }\n\n                        API.sources = sources;\n                        scope.changeSource();\n                    }\n                };\n\n                scope.changeSource = function changeSource() {\n                    var canPlay = \"\";\n\n                    // It's a cool browser\n                    if (API.mediaElement[0].canPlayType) {\n                        for (var i = 0, l = sources.length; i < l; i++) {\n                            canPlay = API.mediaElement[0].canPlayType(sources[i].type);\n\n                            if (canPlay == \"maybe\" || canPlay == \"probably\") {\n                                API.mediaElement.attr(\"src\", sources[i].src);\n                                API.mediaElement.attr(\"type\", sources[i].type);\n                                //Trigger vgChangeSource($source) API callback in vgController\n                                API.changeSource(sources[i]);\n                                break;\n                            }\n                        }\n                    }\n                    // It's a crappy browser and it doesn't deserve any respect\n                    else {\n                        // Get H264 or the first one\n                        API.mediaElement.attr(\"src\", sources[0].src);\n                        API.mediaElement.attr(\"type\", sources[0].type);\n                        //Trigger vgChangeSource($source) API callback in vgController\n                        API.changeSource(sources[0]);\n                    }\n\n                    // Android 2.3 support: https://github.com/2fdevs/videogular/issues/187\n                    if (VG_UTILS.isMobileDevice()) API.mediaElement[0].load();\n\n                    $timeout(function () {\n                        if (API.autoPlay && !VG_UTILS.isMobileDevice()) {\n                            API.play();\n                        }\n                    });\n\n                    if (canPlay == \"\") {\n                        API.onVideoError();\n                    }\n                };\n\n                // INIT\n                API.mediaElement = elem.find(attrs.vgType);\n                API.sources = scope.vgSrc;\n\n                API.addListeners();\n                API.onVideoReady();\n\n                scope.$watch(\"vgSrc\", scope.onChangeSource);\n                scope.$watch(\n                    function() {\n                        return API.sources;\n                    },\n                    scope.onChangeSource\n                );\n\n                scope.$watch(\n                    function() {\n                        return API.playsInline;\n                    },\n                    function (newValue, oldValue) {\n                        if (newValue) API.mediaElement.attr(\"webkit-playsinline\", \"\");\n                        else API.mediaElement.removeAttr(\"webkit-playsinline\");\n                    }\n                );\n\n\n                if (API.isConfig) {\n                    scope.$watch(\n                        function () {\n                            return API.config;\n                        },\n                        function () {\n                            if (API.config) {\n                                scope.vgSrc = API.config.sources;\n                            }\n                        }\n                    );\n                }\n            }\n        }\n    }\n    ]);\n\n/**\n * @ngdoc directive\n * @name com.2fdevs.videogular.directive:vgNativeControls\n * @restrict A\n * @description\n * Optional directive for `vg-media` to add or remove the native controls. Possible values are: \"true\" and \"false\"\n *\n */\n\"use strict\";\nangular.module(\"com.2fdevs.videogular\")\n    .directive(\"vgNativeControls\",\n    [function () {\n        return {\n            restrict: \"A\",\n            require: \"^videogular\",\n            link: {\n                pre: function (scope, elem, attr, API) {\n                    var controls;\n\n                    scope.setControls = function setControls(value) {\n                        if (value) {\n                            API.mediaElement.attr(\"controls\", value);\n                        }\n                        else {\n                            API.mediaElement.removeAttr(\"controls\");\n                        }\n                    };\n\n                    if (API.isConfig) {\n                        scope.$watch(\n                            function () {\n                                return API.config;\n                            },\n                            function () {\n                                if (API.config) {\n                                    scope.setControls(API.config.controls);\n                                }\n                            }\n                        );\n                    }\n                    else {\n                        scope.$watch(attr.vgNativeControls, function (newValue, oldValue) {\n                            if ((!controls || newValue != oldValue) && newValue) {\n                                controls = newValue;\n                                scope.setControls(controls);\n                            }\n                            else {\n                                scope.setControls();\n                            }\n                        });\n                    }\n                }\n            }\n        }\n    }\n    ]);\n\n/**\n * @ngdoc directive\n * @name com.2fdevs.videogular.directive:vgPreload\n * @restrict A\n * @description\n * Optional directive for `vg-media` to preload media files. Possible values are: \"auto\", \"none\" and \"preload\"\n *\n */\n\"use strict\";\nangular.module(\"com.2fdevs.videogular\")\n    .directive(\"vgPreload\",\n    [function () {\n        return {\n            restrict: \"A\",\n            require: \"^videogular\",\n            link: {\n                pre: function (scope, elem, attr, API) {\n                    var preload;\n\n                    scope.setPreload = function setPreload(value) {\n                        if (value) {\n                            API.mediaElement.attr(\"preload\", value);\n                        }\n                        else {\n                            API.mediaElement.removeAttr(\"preload\");\n                        }\n                    };\n\n                    if (API.isConfig) {\n                        scope.$watch(\n                            function () {\n                                return API.config;\n                            },\n                            function () {\n                                if (API.config) {\n                                    scope.setPreload(API.config.preload);\n                                }\n                            }\n                        );\n                    }\n                    else {\n                        scope.$watch(attr.vgPreload, function (newValue, oldValue) {\n                            if ((!preload || newValue != oldValue) && newValue) {\n                                preload = newValue;\n                                scope.setPreload(preload);\n                            }\n                            else {\n                                scope.setPreload();\n                            }\n                        });\n                    }\n                }\n            }\n        }\n    }\n    ]);\n\n/**\n * @ngdoc directive\n * @name com.2fdevs.videogular.directive:vgTracks\n * @restrict A\n * @description\n * Optional directive for `vg-media` to add a list of tracks.\n *\n * vgTracks Bindable array with a list of subtitles sources. A track source is an object with five properties: src, kind, srclang, label and default.\n * <pre>\n * {\n *    src: \"assets/subs/pale-blue-dot.vtt\",\n *    kind: \"subtitles\",\n *    srclang: \"en\",\n *    label: \"English\",\n *    default: \"true/false\"\n * }\n * </pre>\n */\n\"use strict\";\nangular.module(\"com.2fdevs.videogular\")\n    .directive(\"vgTracks\",\n    [function () {\n        return {\n            restrict: \"A\",\n            require: \"^videogular\",\n            link: {\n                pre: function (scope, elem, attr, API) {\n                    var isMetaDataLoaded = false;\n                    var tracks;\n                    var i;\n                    var l;\n\n                    scope.onLoadMetaData = function() {\n                        isMetaDataLoaded = true;\n                        scope.updateTracks();\n                    };\n\n                    scope.updateTracks = function() {\n                        // Remove previous tracks\n                        var oldTracks = API.mediaElement.children();\n\n                        for (i = 0, l = oldTracks.length; i < l; i++) {\n                            if (oldTracks[i].remove) {\n                                oldTracks[i].remove();\n                            }\n                        }\n\n                        // Add new tracks\n                        if (tracks) {\n                            for (i = 0, l = tracks.length; i < l; i++) {\n                                var track = document.createElement('track');\n                                for (var prop in tracks[i]) {\n                                    track[prop] = tracks[i][prop];\n                                }\n\n                                track.addEventListener('load', scope.onLoadTrack.bind(scope, track));\n\n                                API.mediaElement[0].appendChild(track);\n                            }\n                        }\n                    };\n\n                    scope.onLoadTrack = function(track) {\n                        if (track.default) track.mode = 'showing';\n                        else track.mode = 'hidden';\n\n                        for (var i=0, l=API.mediaElement[0].textTracks.length; i<l; i++) {\n                            if (track.label == API.mediaElement[0].textTracks[i].label) {\n                                if (track.default) {\n                                    API.mediaElement[0].textTracks[i].mode = 'showing';\n                                }\n                                else {\n                                    API.mediaElement[0].textTracks[i].mode = 'disabled';\n                                }\n                            }\n\n                        }\n\n                        track.removeEventListener('load', scope.onLoadTrack.bind(scope, track));\n                    };\n\n                    scope.setTracks = function setTracks(value) {\n                        // Add tracks to the API to have it available for other plugins (like controls)\n                        tracks = value;\n                        API.tracks = value;\n\n                        if (isMetaDataLoaded) {\n                            scope.updateTracks();\n                        }\n                        else {\n                            API.mediaElement[0].addEventListener(\"loadedmetadata\", scope.onLoadMetaData.bind(scope), false);\n                        }\n                    };\n\n                    if (API.isConfig) {\n                        scope.$watch(\n                            function () {\n                                return API.config;\n                            },\n                            function () {\n                                if (API.config) {\n                                    scope.setTracks(API.config.tracks);\n                                }\n                            }\n                        );\n                    }\n                    else {\n                        scope.$watch(attr.vgTracks, function (newValue, oldValue) {\n                            if ((!tracks || newValue != oldValue)) {\n                                scope.setTracks(newValue);\n                            }\n                        }, true);\n                    }\n                }\n            }\n        }\n    }\n    ]);\n\n/**\n * @ngdoc directive\n * @name com.2fdevs.videogular.directive:videogular\n * @restrict E\n * @description\n * Main directive that must wrap a &lt;vg-media&gt; tag and all plugins.\n *\n * &lt;video&gt; tag usually will be above plugin tags, that's because plugins should be in a layer over the &lt;video&gt;.\n *\n * @param {string} vgTheme String with a scope name variable. This directive will inject a CSS link in the header of your page.\n * **This parameter is required.**\n *\n * @param {boolean} [vgPlaysInline=false] vgPlaysInline Boolean value or a String with a scope name variable to use native fullscreen (default) or set fullscreen inside browser (true).\n *\n * @param {boolean} [vgClearMediaOnNavigate=true] vgClearMediaOnNavigate Boolean value or a String with a scope name variable to reset the video player when user navigates.\n *\n * This is useful to allow continuous playback between different routes.\n *\n * @param {boolean} [vgAutoPlay=false] vgAutoPlay Boolean value or a String with a scope name variable to auto start playing video when it is initialized.\n *\n * **This parameter is disabled in mobile devices** because user must click on content to prevent consuming mobile data plans.\n *\n * @param {object} vgCuePoints Bindable object containing a list of timelines with cue points objects. A timeline is an array of objects with the following properties:\n * - `timeLapse` is an object with two properties `start` and `end` representing in seconds the period for this cue points.\n * - `onEnter` callback called when user enters on a cue point. callback(currentTime, timeLapse, params)\n * - `onLeave` callback called when user seeks backwards and leave the current cue point or a completed cue point. callback(currentTime, timeLapse, params)\n * - `onUpdate` callback called when the current time is between timeLapse.start and timeLapse.end. callback(currentTime, timeLapse, params)\n * - `onComplete` callback called when the user seek forward or the current time passes timeLapse.end property. callback(currentTime, timeLapse, params)\n * - `params` an object with values available to receive in the callback..\n *\n * @param {function} vgConfig String with a url to a config file. Config file's must be a JSON file object with the following structure:\n * <pre>\n {\n   \"controls\": false,\n   \"loop\": false,\n   \"autoplay\": false,\n   \"preload\": \"auto\",\n   \"theme\": \"path/to/videogular.css\",\n   \"sources\": [\n     {\n       \"src\": \"path/to/videogular.mp4\",\n       \"type\": \"video/mp4\"\n     },\n     {\n       \"src\": \"path/to/videogular.webm\",\n       \"type\": \"video/webm\"\n     },\n     {\n       \"src\": \"path/to/videogular.ogg\",\n       \"type\": \"video/ogg\"\n     }\n   ],\n   \"tracks\": [\n     {\n       \"src\": \"path/to/pale-blue-dot.vtt\",\n       \"kind\": \"subtitles\",\n       \"srclang\": \"en\",\n       \"label\": \"English\",\n       \"default\": \"\"\n     }\n   ],\n   \"plugins\": {\n     \"controls\": {\n       \"autohide\": true,\n       \"autohideTime\": 3000\n     },\n     \"poster\": {\n       \"url\": \"path/to/earth.png\"\n     },\n     \"ima-ads\": {\n       \"companion\": \"companionAd\",\n       \"companionSize\": [728, 90],\n       \"network\": \"6062\",\n       \"unitPath\": \"iab_vast_samples\",\n       \"adTagUrl\": \"http://pubads.g.doubleclick.net/gampad/ads?sz=640x480&iu=%2F3510761%2FadRulesSampleTags&ciu_szs=160x600%2C300x250%2C728x90&cust_params=adrule%3Dpremidpostpodandbumpers&impl=s&gdfp_req=1&env=vp&ad_rule=1&vid=47570401&cmsid=481&output=xml_vast2&unviewed_position_start=1&url=[referrer_url]&correlator=[timestamp]\",\n       \"skipButton\": \"<div class='skipButton'>skip ad</div>\"\n     },\n     \"analytics\": {\n       \"category\": \"Videogular\",\n       \"label\": \"Main\",\n       \"events\": {\n         \"ready\": true,\n         \"play\": true,\n         \"pause\": true,\n         \"stop\": true,\n         \"complete\": true,\n         \"progress\": 10\n       }\n     }\n   }\n }\n * </pre>\n * @param {function} vgCanPlay Function name in controller's scope to call when video is able to begin playback\n * @param {function} vgComplete Function name in controller's scope to call when video have been completed.\n * @param {function} vgUpdateVolume Function name in controller's scope to call when volume changes. Receives a param with the new volume.\n * @param {function} vgUpdatePlayback Function name in controller's scope to call when playback changes. Receives a param with the new playback rate.\n * @param {function} vgUpdateTime Function name in controller's scope to call when video playback time is updated. Receives two params with current time and duration in milliseconds.\n * @param {function} vgUpdateState Function name in controller's scope to call when video state changes. Receives a param with the new state. Possible values are \"play\", \"stop\" or \"pause\".\n * @param {function} vgPlayerReady Function name in controller's scope to call when video have been initialized. Receives a param with the videogular API.\n * @param {function} vgChangeSource Function name in controller's scope to change current video source. Receives a param with the new video.\n * @param {function} vgPlaysInline Boolean to play video inline. Generally used in mobile devices.\n * @param {function} vgNativeFullscreen Boolean to disable native fullscreen.\n * @param {function} vgSeeking Function name in controller's scope to call when the video has finished jumping to a new time. Receives a param with the seeked time and duration in seconds.\n * @param {function} vgSeeked Function name in controller's scope to call when the video is jumping to a new time. Receives two params with the seeked time and duration in seconds.\n * @param {function} vgError Function name in controller's scope to receive an error from video object. Receives a param with the error event.\n * This is a free parameter and it could be values like \"new.mp4\", \"320\" or \"sd\". This will allow you to use this to change a video or video quality.\n * This callback will not change the video, you should do that by updating your sources scope variable.\n *\n */\n\"use strict\";\nangular.module(\"com.2fdevs.videogular\")\n    .directive(\"videogular\",\n    [function () {\n        return {\n            restrict: \"EA\",\n            scope: {\n                vgTheme: \"=?\",\n                vgAutoPlay: \"=?\",\n                vgPlaysInline: \"=?\",\n                vgNativeFullscreen: \"=?\",\n                vgClearMediaOnNavigate: \"=?\",\n                vgCuePoints: \"=?\",\n                vgConfig: \"@\",\n                vgCanPlay: \"&\",\n                vgComplete: \"&\",\n                vgUpdateVolume: \"&\",\n                vgUpdatePlayback: \"&\",\n                vgUpdateTime: \"&\",\n                vgUpdateState: \"&\",\n                vgPlayerReady: \"&\",\n                vgChangeSource: \"&\",\n                vgSeeking: \"&\",\n                vgSeeked: \"&\",\n                vgError: \"&\"\n            },\n            controller: \"vgController\",\n            controllerAs: \"API\",\n            link: {\n                pre: function (scope, elem, attr, controller) {\n                    controller.videogularElement = angular.element(elem);\n                }\n            }\n        }\n    }\n    ]);\n\n/**\n * @ngdoc service\n * @name com.2fdevs.videogular.service:vgConfigLoader\n *\n * @description\n * Config loader service:\n *\n * vgConfigLoader.loadConfig(url): Param `url` is a url to a config JSON.\n **/\n\"use strict\";\nangular.module(\"com.2fdevs.videogular\")\n    .service(\"vgConfigLoader\", [\"$http\", \"$q\", \"$sce\", function ($http, $q, $sce) {\n        this.loadConfig = function loadConfig(url) {\n            var deferred = $q.defer();\n\n            $http({method: 'GET', url: url}).then(\n                function success(response) {\n                    var result = response.data;\n\n                    for (var i = 0, l = result.sources.length; i < l; i++) {\n                        result.sources[i].src = $sce.trustAsResourceUrl(result.sources[i].src);\n                    }\n\n                    deferred.resolve(result);\n                },\n                function reject() {\n                    deferred.reject();\n                }\n            );\n\n            return deferred.promise;\n        };\n    }]);\n\n/**\n * @ngdoc service\n * @name com.2fdevs.videogular.service:vgFullscreen\n *\n * @description\n * Native fullscreen polyfill service.\n *\n *    * vgFullscreen.onchange: String with the onchange event name.\n *    * vgFullscreen.onerror: String with the onerror event name.\n *    * vgFullscreen.isAvailable: Boolean with fullscreen availability.\n *    * vgFullscreen.isFullScreen: Boolean with current view mode.\n *    * vgFullscreen.exit: Exit fullscreen function.\n *    * vgFullscreen.request: Request for fullscreen access function.\n **/\n\"use strict\";\nangular.module(\"com.2fdevs.videogular\")\n    .service(\"vgFullscreen\", [\"VG_UTILS\", function (VG_UTILS) {\n        // Native fullscreen polyfill\n        var element;\n        var polyfill = null;\n        var APIs = {\n            w3: {\n                enabled: \"fullscreenEnabled\",\n                element: \"fullscreenElement\",\n                request: \"requestFullscreen\",\n                exit: \"exitFullscreen\",\n                onchange: \"fullscreenchange\",\n                onerror: \"fullscreenerror\"\n            },\n            newWebkit: {\n                enabled: \"webkitFullscreenEnabled\",\n                element: \"webkitFullscreenElement\",\n                request: \"webkitRequestFullscreen\",\n                exit: \"webkitExitFullscreen\",\n                onchange: \"webkitfullscreenchange\",\n                onerror: \"webkitfullscreenerror\"\n            },\n            oldWebkit: {\n                enabled: \"webkitIsFullScreen\",\n                element: \"webkitCurrentFullScreenElement\",\n                request: \"webkitRequestFullScreen\",\n                exit: \"webkitCancelFullScreen\",\n                onchange: \"webkitfullscreenchange\",\n                onerror: \"webkitfullscreenerror\"\n            },\n            moz: {\n                enabled: \"mozFullScreen\",\n                element: \"mozFullScreenElement\",\n                request: \"mozRequestFullScreen\",\n                exit: \"mozCancelFullScreen\",\n                onchange: \"mozfullscreenchange\",\n                onerror: \"mozfullscreenerror\"\n            },\n            ios: {\n                enabled: \"webkitFullscreenEnabled\",\n                element: \"webkitFullscreenElement\",\n                request: \"webkitEnterFullscreen\",\n                exit: \"webkitExitFullscreen\",\n                onchange: \"webkitfullscreenchange\",\n                onerror: \"webkitfullscreenerror\"\n            },\n            ms: {\n                enabled: \"msFullscreenEnabled\",\n                element: \"msFullscreenElement\",\n                request: \"msRequestFullscreen\",\n                exit: \"msExitFullscreen\",\n                onchange: \"MSFullscreenChange\",\n                onerror: \"MSFullscreenError\"\n            }\n        };\n\n        for (var browser in APIs) {\n            if (APIs[browser].enabled in document) {\n                polyfill = APIs[browser];\n                break;\n            }\n        }\n\n        // Override APIs on iOS\n        if (VG_UTILS.isiOSDevice()) {\n            polyfill = APIs.ios;\n        }\n\n        function isFullScreen() {\n            var result = false;\n\n            if (element) {\n                result = (document[polyfill.element] != null || element.webkitDisplayingFullscreen)\n            }\n            else {\n                result = (document[polyfill.element] != null)\n            }\n\n            return result;\n        }\n\n        this.isAvailable = (polyfill != null);\n\n        if (polyfill) {\n            this.onchange = polyfill.onchange;\n            this.onerror = polyfill.onerror;\n            this.isFullScreen = isFullScreen;\n            this.exit = function () {\n                document[polyfill.exit]();\n            };\n            this.request = function (elem) {\n                element = elem;\n                element[polyfill.request]();\n            };\n        }\n    }]);\n\n\"use strict\";\nangular.module(\"com.2fdevs.videogular\")\n    .service(\"VG_UTILS\", [\"$window\", function ($window) {\n        this.fixEventOffset = function ($event) {\n            /**\n             * There's no offsetX in Firefox, so we fix that.\n             * Solution provided by Jack Moore in this post:\n             * http://www.jacklmoore.com/notes/mouse-position/\n             * @param $event\n             * @returns {*}\n             */\n            var matchedFF = navigator.userAgent.match(/Firefox\\/(\\d+)/i)\n            if (matchedFF && Number.parseInt(matchedFF.pop()) < 39) {\n                var style = $event.currentTarget.currentStyle || window.getComputedStyle($event.target, null);\n                var borderLeftWidth = parseInt(style['borderLeftWidth'], 10);\n                var borderTopWidth = parseInt(style['borderTopWidth'], 10);\n                var rect = $event.currentTarget.getBoundingClientRect();\n                var offsetX = $event.clientX - borderLeftWidth - rect.left;\n                var offsetY = $event.clientY - borderTopWidth - rect.top;\n\n                $event.offsetX = offsetX;\n                $event.offsetY = offsetY;\n            }\n\n            return $event;\n        };\n\n        /**\n         * Inspired by Paul Irish\n         * https://gist.github.com/paulirish/211209\n         * @returns {number}\n         */\n        this.getZIndex = function () {\n            var zIndex = 1;\n            var elementZIndex;\n\n            var tags = document.getElementsByTagName('*');\n\n            for (var i = 0, l = tags.length; i < l; i++) {\n                elementZIndex = parseInt(window.getComputedStyle(tags[i])[\"z-index\"]);\n\n                if (elementZIndex > zIndex) {\n                    zIndex = elementZIndex + 1;\n                }\n            }\n\n            return zIndex;\n        };\n\n        // Very simple mobile detection, not 100% reliable\n        this.isMobileDevice = function () {\n            return (typeof window.orientation !== \"undefined\") || (navigator.userAgent.indexOf(\"IEMobile\") !== -1);\n        };\n\n        this.isiOSDevice = function () {\n            return (navigator.userAgent.match(/iPhone/i) || navigator.userAgent.match(/iPod/i) || navigator.userAgent.match(/iPad/i));\n        };\n\n        /**\n         * Test the browser's support for HTML5 localStorage.\n         * @returns {boolean}\n         */\n        this.supportsLocalStorage = function () {\n            var testKey = 'videogular-test-key';\n            var storage = $window.sessionStorage;\n\n            try {\n                storage.setItem(testKey, '1');\n                storage.removeItem(testKey);\n                return 'localStorage' in $window && $window['localStorage'] !== null;\n            } catch (e) {\n                return false;\n            }\n        };\n    }]);\n\ndefine(\"videogular\", function(){});\n\n",
    "/**\n * @license Videogular v0.6.3 http://videogular.com\n * Two Fucking Developers http://twofuckingdevelopers.com\n * License: MIT\n */\n\"use strict\";\n/**\n * @ngdoc directive\n * @name com.2fdevs.videogular.plugins.buffering:vgBuffering\n * @restrict E\n * @description\n * Shows a spinner when Videogular is buffering or preparing the video player.\n *\n * ```html\n * <videogular vg-theme=\"config.theme.url\" vg-autoplay=\"config.autoPlay\">\n *    <vg-video vg-src=\"sources\"></vg-video>\n *\n *    <vg-buffering></vg-buffering>\n * </videogular>\n * ```\n *\n */\nangular.module(\"com.2fdevs.videogular.plugins.buffering\", [])\n\t.directive(\n\t\"vgBuffering\",\n\t[\"VG_UTILS\", function (VG_UTILS) {\n\t\treturn {\n\t\t\trestrict: \"E\",\n\t\t\trequire: \"^videogular\",\n\t\t\ttemplate: \"<div class='bufferingContainer'>\" +\n\t\t\t\t\"<div ng-class='spinnerClass' class='loadingSpinner'></div>\" +\n\t\t\t\t\"</div>\",\n\t\t\tlink: function (scope, elem, attr, API) {\n\t\t\t\tfunction showSpinner() {\n\t\t\t\t\tscope.spinnerClass = {stop: API.isBuffering};\n\t\t\t\t\telem.css(\"display\", \"block\");\n\t\t\t\t}\n\n\t\t\t\tfunction hideSpinner() {\n\t\t\t\t\tscope.spinnerClass = {stop: API.isBuffering};\n\t\t\t\t\telem.css(\"display\", \"none\");\n\t\t\t\t}\n\n\t\t\t\tfunction setState(isBuffering) {\n\t\t\t\t\tif (isBuffering) {\n\t\t\t\t\t\tshowSpinner();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\thideSpinner();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfunction onPlayerReady(isReady) {\n\t\t\t\t\tif (isReady) {\n\t\t\t\t\t\thideSpinner();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tshowSpinner();\n\n\t\t\t\t// Workaround for issue #16: https://github.com/2fdevs/videogular/issues/16\n\t\t\t\tif (VG_UTILS.isMobileDevice()) {\n\t\t\t\t\thideSpinner();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tscope.$watch(\n\t\t\t\t\t\tfunction () {\n\t\t\t\t\t\t\treturn API.isReady;\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfunction (newVal, oldVal) {\n\t\t\t\t\t\t\tif (API.isReady == true || newVal != oldVal) {\n\t\t\t\t\t\t\t\tonPlayerReady(newVal);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tscope.$watch(\n\t\t\t\t\tfunction () {\n\t\t\t\t\t\treturn API.isBuffering;\n\t\t\t\t\t},\n\t\t\t\t\tfunction (newVal, oldVal) {\n\t\t\t\t\t\tif (newVal != oldVal) {\n\t\t\t\t\t\t\tsetState(newVal);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\t]);\n\ndefine(\"videogular-buffering\", function(){});\n\n",
    "/**\n * @license Videogular v0.6.3 http://videogular.com\n * Two Fucking Developers http://twofuckingdevelopers.com\n * License: MIT\n */\n/**\n * @ngdoc directive\n * @name com.2fdevs.videogular.plugins.controls:vgControls\n * @restrict E\n * @description\n * This directive acts as a container and you will need other directives to control the media.\n * Inside this directive you can add other directives like vg-play-pause-button and vg-scrubbar.\n *\n * @param {boolean=false} vgAutohide Boolean variable or value to activate autohide.\n * @param {number=2000} vgAutohideTime Number variable or value that represents the time in milliseconds that will wait vgControls until it hides.\n *\n * ```html\n * <videogular vg-theme=\"config.theme.url\">\n *    <vg-video vg-src=\"sources\"></vg-video>\n *\n *    <vg-controls vg-autohide='config.autohide' vg-autohide-time='config.autohideTime'></vg-controls>\n * </videogular>\n * ```\n *\n */\n\"use strict\";\nangular.module(\"com.2fdevs.videogular.plugins.controls\", [])\n\t.directive(\n\t\"vgControls\",\n\t[\"$timeout\", \"VG_STATES\", function ($timeout, VG_STATES) {\n\t\treturn {\n\t\t\trestrict: \"E\",\n\t\t\trequire: \"^videogular\",\n\t\t\ttransclude: true,\n\t\t\ttemplate: '<div id=\"controls-container\" ng-mousemove=\"onMouseMove()\" ng-class=\"animationClass\" ng-transclude></div>',\n\t\t\tscope: {\n\t\t\t\tautoHide: \"=vgAutohide\",\n\t\t\t\tautoHideTime: \"=vgAutohideTime\"\n\t\t\t},\n\t\t\tlink: function (scope, elem, attr, API) {\n\t\t\t\tvar w = 0;\n\t\t\t\tvar h = 0;\n\t\t\t\tvar autoHideTime = 2000;\n\t\t\t\tvar hideInterval;\n\n\t\t\t\tscope.onMouseMove = function onMouseMove() {\n\t\t\t\t\tif (scope.autoHide) showControls();\n\t\t\t\t};\n\n\t\t\t\tfunction hideControls() {\n\t\t\t\t\tscope.animationClass = \"hide-animation\";\n\t\t\t\t}\n\n\t\t\t\tfunction showControls() {\n\t\t\t\t\tscope.animationClass = \"show-animation\";\n\t\t\t\t\t$timeout.cancel(hideInterval);\n\t\t\t\t\tif (scope.autoHide) hideInterval = $timeout(hideControls, autoHideTime);\n\t\t\t\t}\n\n\t\t\t\t// If vg-autohide has been set\n\t\t\t\tif (scope.autoHide != undefined) {\n\t\t\t\t\tscope.$watch(\"autoHide\", function (value) {\n\t\t\t\t\t\tif (value) {\n\t\t\t\t\t\t\tscope.animationClass = \"hide-animation\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tscope.animationClass = \"\";\n\t\t\t\t\t\t\t$timeout.cancel(hideInterval);\n\t\t\t\t\t\t\tshowControls();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// If vg-autohide-time has been set\n\t\t\t\tif (scope.autoHideTime != undefined) {\n\t\t\t\t\tscope.$watch(\"autoHideTime\", function (value) {\n\t\t\t\t\t\tautoHideTime = value;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t])\n/**\n * @ngdoc directive\n * @name com.2fdevs.videogular.plugins.controls:vgPlayPauseButton\n * @restrict E\n * @description\n * Adds a button inside vg-controls to play and pause media.\n *\n * ```html\n * <videogular vg-theme=\"config.theme.url\">\n *    <vg-video vg-src=\"sources\"></vg-video>\n *\n *    <vg-controls vg-autohide='config.autohide' vg-autohide-time='config.autohideTime'>\n *        <vg-play-pause-button></vg-play-pause-button>\n *    </vg-controls>\n * </videogular>\n * ```\n *\n */\n\t.directive(\n\t\"vgPlayPauseButton\",\n\t[\"VG_STATES\", function (VG_STATES) {\n\t\treturn {\n\t\t\trestrict: \"E\",\n\t\t\trequire: \"^videogular\",\n\t\t\ttemplate: \"<button class='iconButton' ng-click='onClickPlayPause()' ng-class='playPauseIcon' aria-label='Play/Pause'></button>\",\n\t\t\tlink: function (scope, elem, attr, API) {\n\t\t\t\tfunction setState(newState) {\n\t\t\t\t\tswitch (newState) {\n\t\t\t\t\t\tcase VG_STATES.PLAY:\n\t\t\t\t\t\t\tscope.playPauseIcon = {pause: true};\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase VG_STATES.PAUSE:\n\t\t\t\t\t\t\tscope.playPauseIcon = {play: true};\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase VG_STATES.STOP:\n\t\t\t\t\t\t\tscope.playPauseIcon = {play: true};\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tscope.onClickPlayPause = function onClickPlayPause() {\n\t\t\t\t\tAPI.playPause();\n\t\t\t\t};\n\n\t\t\t\tscope.playPauseIcon = {play: true};\n\n\t\t\t\tscope.$watch(\n\t\t\t\t\tfunction () {\n\t\t\t\t\t\treturn API.currentState;\n\t\t\t\t\t},\n\t\t\t\t\tfunction (newVal, oldVal) {\n\t\t\t\t\t\tif (newVal != oldVal) {\n\t\t\t\t\t\t\tsetState(newVal);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\t])\n/**\n * @ngdoc directive\n * @name com.2fdevs.videogular.plugins.controls:vgTimedisplay\n * @restrict E\n * @description\n * Adds a time display inside vg-controls to play and pause media.\n * You have three scope variables to show current time, time left and total time.\n *\n * Those scope variables are type Date so you can add a date filter to show the time as you wish.\n *\n * ```html\n * <videogular vg-theme=\"config.theme.url\">\n *    <vg-video vg-src=\"sources\"></vg-video>\n *\n *    <vg-controls vg-autohide='config.autohide' vg-autohide-time='config.autohideTime'>\n *        <vg-timedisplay>{{currentTime | date:'hh:mm'}}</vg-timedisplay>\n *        <vg-timedisplay>{{timeLeft | date:'mm:ss'}}</vg-timedisplay>\n *        <vg-timedisplay>{{totalTime | date:'hh:mm:ss'}}</vg-timedisplay>\n *    </vg-controls>\n * </videogular>\n * ```\n *\n */\n\t.directive(\n\t\"vgTimedisplay\",\n\t[function () {\n\t\treturn {\n\t\t\trequire: \"^videogular\",\n\t\t\trestrict: \"E\",\n\t\t\tlink: function (scope, elem, attr, API) {\n\t\t\t\tscope.$watch(\n\t\t\t\t\tfunction () {\n\t\t\t\t\t\treturn API.currentTime;\n\t\t\t\t\t},\n\t\t\t\t\tfunction (newVal, oldVal) {\n\t\t\t\t\t\tif (newVal != oldVal) {\n\t\t\t\t\t\t\tscope.currentTime = newVal;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\tscope.$watch(\n\t\t\t\t\tfunction () {\n\t\t\t\t\t\treturn API.timeLeft;\n\t\t\t\t\t},\n\t\t\t\t\tfunction (newVal, oldVal) {\n\t\t\t\t\t\tif (newVal != oldVal) {\n\t\t\t\t\t\t\tscope.timeLeft = newVal;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\tscope.$watch(\n\t\t\t\t\tfunction () {\n\t\t\t\t\t\treturn API.totalTime;\n\t\t\t\t\t},\n\t\t\t\t\tfunction (newVal, oldVal) {\n\t\t\t\t\t\tif (newVal != oldVal) {\n\t\t\t\t\t\t\tscope.totalTime = newVal;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\t])\n/**\n * @ngdoc directive\n * @name com.2fdevs.videogular.plugins.controls:vgScrubbar\n * @restrict E\n * @description\n * Directive to control the time and display other information layers about the progress of the media.\n * This directive acts as a container and you can add more layers to display current time, cuepoints, buffer or whatever you need.\n *\n * ```html\n * <videogular vg-theme=\"config.theme.url\">\n *    <vg-video vg-src=\"sources\"></vg-video>\n *\n *    <vg-controls vg-autohide='config.autohide' vg-autohide-time='config.autohideTime'>\n *        <vg-scrubbar></vg-scrubbar>\n *    </vg-controls>\n * </videogular>\n * ```\n *\n */\n\t.directive(\n\t\"vgScrubbar\",\n\t[\"VG_STATES\", \"VG_UTILS\", function (VG_STATES, VG_UTILS) {\n\t\treturn {\n\t\t\trestrict: \"AE\",\n\t\t\trequire: \"^videogular\",\n\t\t\ttransclude: true,\n\t\t\ttemplate: '<div role=\"slider\" aria-valuemax=\"{{ariaTime(API.totalTime)}}\" ' +\n\t\t\t\t\t'aria-valuenow=\"{{ariaTime(API.currentTime)}}\" ' +\n\t\t\t\t\t'aria-valuemin=\"0\" aria-label=\"Time scrub bar\" tabindex=\"0\" ' +\n\t\t\t        'ng-transclude ng-keydown=\"onScrubBarKeyDown($event)\"></div>',\n\t\t\tlink: function (scope, elem, attr, API) {\n\t\t\t\tvar isSeeking = false;\n\t\t\t\tvar isPlaying = false;\n\t\t\t\tvar isPlayingWhenSeeking = false;\n\t\t\t\tvar touchStartX = 0;\n\t\t\t\tvar LEFT = 37;\n\t\t\t\tvar RIGHT = 39;\n\t\t\t\tvar NUM_PERCENT = 1;\n\n\t\t\t\tscope.API = API;\n\t\t\t\tscope.ariaTime = function(time) {\n\t\t\t\t\treturn (time === 0) ? \"0\" : Math.round(time.getTime() / 1000);\n\t\t\t\t};\n\n\t\t\t\tfunction onScrubBarTouchStart($event) {\n\t\t\t\t\tvar event = $event.originalEvent || $event;\n\t\t\t\t\tvar touches = event.touches;\n\t\t\t\t\tvar touchX;\n\n\t\t\t\t\tif (VG_UTILS.isiOSDevice()) {\n\t\t\t\t\t\ttouchStartX = (touches[0].clientX - event.layerX) * -1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttouchStartX = event.layerX;\n\t\t\t\t\t}\n\n\t\t\t\t\ttouchX = touches[0].clientX + touchStartX - touches[0].target.offsetLeft;\n\n\t\t\t\t\tisSeeking = true;\n\t\t\t\t\tif (isPlaying) isPlayingWhenSeeking = true;\n\t\t\t\t\tAPI.pause();\n\t\t\t\t\tseekTime(touchX * API.mediaElement[0].duration / elem[0].scrollWidth);\n\n\t\t\t\t\tscope.$apply();\n\t\t\t\t}\n\n\t\t\t\tfunction onScrubBarTouchMove($event) {\n\t\t\t\t\tvar event = $event.originalEvent || $event;\n\t\t\t\t\tif (isPlayingWhenSeeking) {\n\t\t\t\t\t\tisPlayingWhenSeeking = false;\n\t\t\t\t\t\tAPI.play();\n\t\t\t\t\t}\n\t\t\t\t\tisSeeking = false;\n\n\t\t\t\t\tscope.$apply();\n\t\t\t\t}\n\n\t\t\t\tfunction onScrubBarTouchMove($event) {\n\t\t\t\t\tvar event = $event.originalEvent || $event;\n\t\t\t\t\tvar touches = event.touches;\n\t\t\t\t\tvar touchX;\n\n\t\t\t\t\tif (isSeeking) {\n\t\t\t\t\t\ttouchX = touches[0].clientX + touchStartX - touches[0].target.offsetLeft;\n\t\t\t\t\t\tseekTime(touchX * API.mediaElement[0].duration / elem[0].scrollWidth);\n\t\t\t\t\t}\n\n\t\t\t\t\tscope.$apply();\n\t\t\t\t}\n\n\t\t\t\tfunction onScrubBarTouchLeave(event) {\n\t\t\t\t\tisSeeking = false;\n\n\t\t\t\t\tscope.$apply();\n\t\t\t\t}\n\n\t\t\t\tfunction onScrubBarMouseDown(event) {\n\t\t\t\t\tevent = VG_UTILS.fixEventOffset(event);\n\n\t\t\t\t\tisSeeking = true;\n\t\t\t\t\tif (isPlaying) isPlayingWhenSeeking = true;\n\t\t\t\t\tAPI.pause();\n\t\t\t\t\tseekTime(event.offsetX * API.mediaElement[0].duration / elem[0].scrollWidth);\n\n\t\t\t\t\tscope.$apply();\n\t\t\t\t}\n\n\t\t\t\tfunction onScrubBarMouseUp(event) {\n\t\t\t\t\tevent = VG_UTILS.fixEventOffset(event);\n\n\t\t\t\t\tif (isPlayingWhenSeeking) {\n\t\t\t\t\t\tisPlayingWhenSeeking = false;\n\t\t\t\t\t\tAPI.play();\n\t\t\t\t\t}\n\t\t\t\t\tisSeeking = false;\n\t\t\t\t\tseekTime(event.offsetX * API.mediaElement[0].duration / elem[0].scrollWidth);\n\n\t\t\t\t\tscope.$apply();\n\t\t\t\t}\n\n\t\t\t\tfunction onScrubBarMouseMove(event) {\n\t\t\t\t\tif (isSeeking) {\n\t\t\t\t\t\tevent = VG_UTILS.fixEventOffset(event);\n\t\t\t\t\t\tseekTime(event.offsetX * API.mediaElement[0].duration / elem[0].scrollWidth);\n\t\t\t\t\t}\n\n\t\t\t\t\tscope.$apply();\n\t\t\t\t}\n\n\t\t\t\tfunction onScrubBarMouseLeave(event) {\n\t\t\t\t\tisSeeking = false;\n\n\t\t\t\t\tscope.$apply();\n\t\t\t\t}\n\n\t\t\t\tscope.onScrubBarKeyDown = function(event) {\n\t\t\t\t\tvar currentPercent = API.currentTime.getTime() / API.totalTime.getTime() * 100;\n\n\t\t\t\t\tif (event.which === LEFT || event.keyCode === LEFT) {\n\t\t\t\t\t\tAPI.seekTime(currentPercent - NUM_PERCENT, true);\n\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t}\n\t\t\t\t\telse if (event.which === RIGHT || event.keyCode === RIGHT) {\n\t\t\t\t\t\tAPI.seekTime(currentPercent + NUM_PERCENT, true);\n\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tfunction seekTime(time) {\n\t\t\t\t\tAPI.seekTime(time, false);\n\t\t\t\t}\n\n\t\t\t\tfunction setState(newState) {\n\t\t\t\t\tif (!isSeeking) {\n\t\t\t\t\t\tswitch (newState) {\n\t\t\t\t\t\t\tcase VG_STATES.PLAY:\n\t\t\t\t\t\t\t\tisPlaying = true;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase VG_STATES.PAUSE:\n\t\t\t\t\t\t\t\tisPlaying = false;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase VG_STATES.STOP:\n\t\t\t\t\t\t\t\tisPlaying = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tscope.$watch(\n\t\t\t\t\tfunction () {\n\t\t\t\t\t\treturn API.currentState;\n\t\t\t\t\t},\n\t\t\t\t\tfunction (newVal, oldVal) {\n\t\t\t\t\t\tif (newVal != oldVal) {\n\t\t\t\t\t\t\tsetState(newVal);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\t// Touch move is really buggy in Chrome for Android, maybe we could use mouse move that works ok\n\t\t\t\tif (VG_UTILS.isMobileDevice()) {\n\t\t\t\t\telem.bind(\"touchstart\", onScrubBarTouchStart);\n\t\t\t\t\telem.bind(\"touchend\", onScrubBarTouchEnd);\n\t\t\t\t\telem.bind(\"touchmove\", onScrubBarTouchMove);\n\t\t\t\t\telem.bind(\"touchleave\", onScrubBarTouchLeave);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\telem.bind(\"mousedown\", onScrubBarMouseDown);\n\t\t\t\t\telem.bind(\"mouseup\", onScrubBarMouseUp);\n\t\t\t\t\telem.bind(\"mousemove\", onScrubBarMouseMove);\n\t\t\t\t\telem.bind(\"mouseleave\", onScrubBarMouseLeave);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t])\n/**\n * @ngdoc directive\n * @name com.2fdevs.videogular.plugins.controls:vgScrubbarcurrenttime\n * @restrict E\n * @description\n * Layer inside vg-scrubbar to display the current time.\n *\n * ```html\n * <videogular vg-theme=\"config.theme.url\">\n *    <vg-video vg-src=\"sources\"></vg-video>\n *\n *    <vg-controls vg-autohide='config.autohide' vg-autohide-time='config.autohideTime'>\n *        <vg-scrubbar>\n *            <vg-scrubbarcurrenttime></vg-scrubbarcurrenttime>\n *        </vg-scrubbar>\n *    </vg-controls>\n * </videogular>\n * ```\n *\n */\n\t.directive(\n\t\"vgScrubbarcurrenttime\",\n\t[function () {\n\t\treturn {\n\t\t\trestrict: \"E\",\n\t\t\trequire: \"^videogular\",\n\t\t\tlink: function (scope, elem, attr, API) {\n\t\t\t\tvar percentTime = 0;\n\n\t\t\t\tfunction onUpdateTime(newCurrentTime) {\n\t\t\t\t\tif (newCurrentTime && API.totalTime) {\n\t\t\t\t\t\tpercentTime = (newCurrentTime.getTime() * -1 / 1000) * 100 / (API.totalTime.getTime() * -1 / 1000);\n\t\t\t\t\t\telem.css(\"width\", percentTime + \"%\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfunction onComplete() {\n\t\t\t\t\tpercentTime = 0;\n\t\t\t\t\telem.css(\"width\", percentTime + \"%\");\n\t\t\t\t}\n\n\t\t\t\tscope.$watch(\n\t\t\t\t\tfunction () {\n\t\t\t\t\t\treturn API.currentTime;\n\t\t\t\t\t},\n\t\t\t\t\tfunction (newVal, oldVal) {\n\t\t\t\t\t\tonUpdateTime(newVal);\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\tscope.$watch(\n\t\t\t\t\tfunction () {\n\t\t\t\t\t\treturn API.isCompleted;\n\t\t\t\t\t},\n\t\t\t\t\tfunction (newVal, oldVal) {\n\t\t\t\t\t\tonComplete(newVal);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\t])\n/**\n * @ngdoc directive\n * @name com.2fdevs.videogular.plugins.controls:vgVolume\n * @restrict E\n * @description\n * Directive to control the volume.\n * This directive acts as a container and you will need other directives like vg-mutebutton and vg-volumebar to control the volume.\n * In mobile will be hided since volume API is disabled for mobile devices.\n *\n * ```html\n * <videogular vg-theme=\"config.theme.url\">\n *    <vg-video vg-src=\"sources\"></vg-video>\n *\n *    <vg-controls vg-autohide='config.autohide' vg-autohide-time='config.autohideTime'>\n *        <vg-volume></vg-volume>\n *    </vg-controls>\n * </videogular>\n * ```\n *\n */\n\t.directive(\n\t\"vgVolume\",\n\t[\"VG_UTILS\", function (VG_UTILS) {\n\t\treturn {\n\t\t\trestrict: \"E\",\n\t\t\tlink: function (scope, elem, attr) {\n\t\t\t\tfunction onMouseOverVolume() {\n\t\t\t\t\tscope.volumeVisibility = \"visible\";\n\t\t\t\t\tscope.$apply();\n\t\t\t\t}\n\n\t\t\t\tfunction onMouseLeaveVolume() {\n\t\t\t\t\tscope.volumeVisibility = \"hidden\";\n\t\t\t\t\tscope.$apply();\n\t\t\t\t}\n\n\t\t\t\t// We hide volume controls on mobile devices\n\t\t\t\tif (VG_UTILS.isMobileDevice()) {\n\t\t\t\t\telem.css(\"display\", \"none\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tscope.volumeVisibility = \"hidden\";\n\n\t\t\t\t\telem.bind(\"mouseover\", onMouseOverVolume);\n\t\t\t\t\telem.bind(\"mouseleave\", onMouseLeaveVolume);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t])\n/**\n * @ngdoc directive\n * @name com.2fdevs.videogular.plugins.controls:vgVolumebar\n * @restrict E\n * @description\n * Directive to display a vertical volume bar to control the volume.\n * This directive must be inside vg-volume directive and requires vg-mutebutton to be displayed.\n *\n * ```html\n * <videogular vg-theme=\"config.theme.url\">\n *    <vg-video vg-src=\"sources\"></vg-video>\n *\n *    <vg-controls vg-autohide='config.autohide' vg-autohide-time='config.autohideTime'>\n *        <vg-volume>\n *            <vg-mutebutton><vg-mutebutton>\n *            <vg-volumebar><vg-volumebar>\n *        </vg-volume>\n *    </vg-controls>\n * </videogular>\n * ```\n *\n */\n\t.directive(\n\t\"vgVolumebar\",\n\t[\"VG_UTILS\", function (VG_UTILS) {\n\t\treturn {\n\t\t\trestrict: \"E\",\n\t\t\trequire: \"^videogular\",\n\t\t\ttemplate: \"<div class='verticalVolumeBar'>\" +\n\t\t\t\t\"<div class='volumeBackground' ng-click='onClickVolume($event)' ng-mousedown='onMouseDownVolume()' ng-mouseup='onMouseUpVolume()' ng-mousemove='onMouseMoveVolume($event)' ng-mouseleave='onMouseLeaveVolume()'>\" +\n\t\t\t\t\"<div class='volumeValue'></div>\" +\n\t\t\t\t\"<div class='volumeClickArea'></div>\" +\n\t\t\t\t\"</div>\" +\n\t\t\t\t\"</div>\",\n\t\t\tlink: function (scope, elem, attr, API) {\n\t\t\t\tvar isChangingVolume = false;\n\t\t\t\tvar volumeBackElem = angular.element(elem[0].getElementsByClassName(\"volumeBackground\"));\n\t\t\t\tvar volumeValueElem = angular.element(elem[0].getElementsByClassName(\"volumeValue\"));\n\n\t\t\t\tscope.onClickVolume = function onClickVolume(event) {\n\t\t\t\t\tevent = VG_UTILS.fixEventOffset(event);\n\t\t\t\t\tvar volumeHeight = parseInt(volumeBackElem.prop(\"offsetHeight\"));\n\t\t\t\t\tvar value = event.offsetY * 100 / volumeHeight;\n\t\t\t\t\tvar volValue = 1 - (value / 100);\n\n\t\t\t\t\tAPI.setVolume(volValue);\n\t\t\t\t};\n\n\t\t\t\tscope.onMouseDownVolume = function onMouseDownVolume() {\n\t\t\t\t\tisChangingVolume = true;\n\t\t\t\t};\n\n\t\t\t\tscope.onMouseUpVolume = function onMouseUpVolume() {\n\t\t\t\t\tisChangingVolume = false;\n\t\t\t\t};\n\n\t\t\t\tscope.onMouseLeaveVolume = function onMouseLeaveVolume() {\n\t\t\t\t\tisChangingVolume = false;\n\t\t\t\t};\n\n\t\t\t\tscope.onMouseMoveVolume = function onMouseMoveVolume(event) {\n\t\t\t\t\tif (isChangingVolume) {\n\t\t\t\t\t\tevent = VG_UTILS.fixEventOffset(event);\n\t\t\t\t\t\tvar volumeHeight = parseInt(volumeBackElem.prop(\"offsetHeight\"));\n\t\t\t\t\t\tvar value = event.offsetY * 100 / volumeHeight;\n\t\t\t\t\t\tvar volValue = 1 - (value / 100);\n\n\t\t\t\t\t\tAPI.setVolume(volValue);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tfunction updateVolumeView(value) {\n\t\t\t\t\tvalue = value * 100;\n\t\t\t\t\tvolumeValueElem.css(\"height\", value + \"%\");\n\t\t\t\t\tvolumeValueElem.css(\"top\", (100 - value) + \"%\");\n\t\t\t\t}\n\n\t\t\t\tfunction onChangeVisibility(value) {\n\t\t\t\t\telem.css(\"visibility\", value);\n\t\t\t\t}\n\n\t\t\t\telem.css(\"visibility\", scope.volumeVisibility);\n\n\t\t\t\tscope.$watch(\"volumeVisibility\", onChangeVisibility);\n\n\t\t\t\tscope.$watch(\n\t\t\t\t\tfunction () {\n\t\t\t\t\t\treturn API.volume;\n\t\t\t\t\t},\n\t\t\t\t\tfunction (newVal, oldVal) {\n\t\t\t\t\t\tif (newVal != oldVal) {\n\t\t\t\t\t\t\tupdateVolumeView(newVal);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\t])\n/**\n * @ngdoc directive\n * @name com.2fdevs.videogular.plugins.controls:vgMutebutton\n * @restrict E\n * @description\n * Directive to display a button to mute volume.\n *\n * ```html\n * <videogular vg-theme=\"config.theme.url\">\n *    <vg-video vg-src=\"sources\"></vg-video>\n *\n *    <vg-controls vg-autohide='config.autohide' vg-autohide-time='config.autohideTime'>\n *        <vg-volume>\n *            <vg-mutebutton><vg-mutebutton>\n *        </vg-volume>\n *    </vg-controls>\n * </videogular>\n * ```\n *\n */\n\t.directive(\n\t\"vgMutebutton\",\n\t[function () {\n\t\treturn {\n\t\t\trestrict: \"E\",\n\t\t\trequire: \"^videogular\",\n\t\t\ttemplate: \"<button class='iconButton' ng-class='muteIcon'\" +\n\t\t\t\t\" ng-click='onClickMute()' ng-focus='onMuteButtonFocus()' ng-blur='onMuteButtonLoseFocus()' ng-keydown='onMuteButtonKeyDown($event)'\" +\n\t\t\t\t\" aria-label='Mute'></button>\",\n\t\t\tlink: function (scope, elem, attr, API) {\n\t\t\t\tvar isMuted = false;\n\t\t\t\tvar UP = 38;\n\t\t\t\tvar DOWN = 40;\n\t\t\t\tvar CHANGE_PER_PRESS = 0.05;\n\n\t\t\t\tscope.onClickMute = function onClickMute() {\n\t\t\t\t\tif (isMuted) {\n\t\t\t\t\t\tscope.currentVolume = scope.defaultVolume;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tscope.currentVolume = 0;\n\t\t\t\t\t\tscope.muteIcon = {mute: true};\n\t\t\t\t\t}\n\n\t\t\t\t\tisMuted = !isMuted;\n\n\t\t\t\t\tAPI.setVolume(scope.currentVolume);\n\t\t\t\t};\n\n\t\t\t\tscope.onMuteButtonFocus = function() {\n\t\t\t\t\tscope.volumeVisibility = 'visible';\n\t\t\t\t};\n\n\t\t\t\tscope.onMuteButtonLoseFocus = function() {\n\t\t\t\t\tscope.volumeVisibility = 'hidden';\n\t\t\t\t};\n\n\t\t\t\tscope.onMuteButtonKeyDown = function(event) {\n\t\t\t\t\tvar currentVolume = (API.volume != null) ? API.volume : 1;\n          var newVolume;\n\n\t\t\t\t\tif (event.which === UP || event.keyCode === UP) {\n            newVolume = currentVolume + CHANGE_PER_PRESS;\n            if (newVolume > 1) newVolume = 1;\n\n\t\t\t\t\t\tAPI.setVolume(newVolume);\n\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t}\n\t\t\t\t\telse if (event.which === DOWN || event.keyCode === DOWN) {\n            newVolume = currentVolume - CHANGE_PER_PRESS;\n            if (newVolume < 0) newVolume = 0;\n\n\t\t\t\t\t\tAPI.setVolume(newVolume);\n\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tfunction onSetVolume(newVolume) {\n          scope.currentVolume = newVolume;\n\n\t\t\t\t\t// TODO: Save volume with LocalStorage\n\t\t\t\t\t// if it's not muted we save the default volume\n\t\t\t\t\tif (!isMuted) {\n\t\t\t\t\t\tscope.defaultVolume = newVolume;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// if was muted but the user changed the volume\n\t\t\t\t\t\tif (newVolume > 0) {\n\t\t\t\t\t\t\tscope.defaultVolume = newVolume;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tvar percentValue = Math.round(newVolume * 100);\n\t\t\t\t\tif (percentValue == 0) {\n\t\t\t\t\t\tscope.muteIcon = {mute: true};\n\t\t\t\t\t}\n\t\t\t\t\telse if (percentValue > 0 && percentValue < 25) {\n\t\t\t\t\t\tscope.muteIcon = {level0: true};\n\t\t\t\t\t}\n\t\t\t\t\telse if (percentValue >= 25 && percentValue < 50) {\n\t\t\t\t\t\tscope.muteIcon = {level1: true};\n\t\t\t\t\t}\n\t\t\t\t\telse if (percentValue >= 50 && percentValue < 75) {\n\t\t\t\t\t\tscope.muteIcon = {level2: true};\n\t\t\t\t\t}\n\t\t\t\t\telse if (percentValue >= 75) {\n\t\t\t\t\t\tscope.muteIcon = {level3: true};\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tscope.defaultVolume = 1;\n\t\t\t\tscope.currentVolume = scope.defaultVolume;\n\t\t\t\tscope.muteIcon = {level3: true};\n\n\t\t\t\t//TODO: get volume from localStorage\n\n\t\t\t\tscope.$watch(\n\t\t\t\t\tfunction () {\n\t\t\t\t\t\treturn API.volume;\n\t\t\t\t\t},\n\t\t\t\t\tfunction (newVal, oldVal) {\n\t\t\t\t\t\tif (newVal != oldVal) {\n\t\t\t\t\t\t\tonSetVolume(newVal);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\t])\n/**\n * @ngdoc directive\n * @name com.2fdevs.videogular.plugins.controls:vgFullscreenbutton\n * @restrict E\n * @description\n * Directive to switch between fullscreen and normal mode.\n *\n * ```html\n * <videogular vg-theme=\"config.theme.url\">\n *    <vg-video vg-src=\"sources\"></vg-video>\n *\n *    <vg-controls vg-autohide='config.autohide' vg-autohide-time='config.autohideTime'>\n *        <vg-fullscreenbutton></vg-fullscreenbutton>\n *    </vg-controls>\n * </videogular>\n * ```\n *\n */\n\t.directive(\n\t\"vgFullscreenbutton\",\n\t[function () {\n\t\treturn {\n\t\t\trestrict: \"AE\",\n\t\t\trequire: \"^videogular\",\n\t\t\tscope: {\n\t\t\t\tvgEnterFullScreenIcon: \"=\",\n\t\t\t\tvgExitFullScreenIcon: \"=\"\n\t\t\t},\n\t\t\ttemplate: \"<button class='iconButton' ng-click='onClickFullScreen()' ng-class='fullscreenIcon' aria-label='Toggle full screen'></button>\",\n\t\t\tlink: function (scope, elem, attr, API) {\n\t\t\t\tfunction onChangeFullScreen(isFullScreen) {\n\t\t\t\t\tscope.fullscreenIcon = {enter: !isFullScreen, exit: isFullScreen};\n\t\t\t\t}\n\n\t\t\t\tscope.onClickFullScreen = function onClickFullScreen() {\n\t\t\t\t\tAPI.toggleFullScreen();\n\t\t\t\t};\n\n\t\t\t\tscope.fullscreenIcon = {exit: false};\n\t\t\t\tscope.fullscreenIcon = {enter: true};\n\n\t\t\t\tscope.$watch(\n\t\t\t\t\tfunction () {\n\t\t\t\t\t\treturn API.isFullScreen;\n\t\t\t\t\t},\n\t\t\t\t\tfunction (newVal, oldVal) {\n\t\t\t\t\t\tif (newVal != oldVal) {\n\t\t\t\t\t\t\tonChangeFullScreen(newVal);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\t]);\n\ndefine(\"videogular-controls\", function(){});\n\n",
    "/**\n * @license Videogular v0.6.3 http://videogular.com\n * Two Fucking Developers http://twofuckingdevelopers.com\n * License: MIT\n */\n\"use strict\";\n/**\n * @ngdoc directive\n * @name com.2fdevs.videogular.plugins.overlayplay:vgOverlayPlay\n * @restrict E\n * @description\n * Shows a big play button centered when player is paused or stopped.\n *\n * ```html\n * <videogular vg-theme=\"config.theme.url\" vg-autoplay=\"config.autoPlay\">\n *    <vg-video vg-src=\"sources\"></vg-video>\n *\n *    <vg-overlay-play></vg-overlay-play>\n * </videogular>\n * ```\n *\n */\nangular.module(\"com.2fdevs.videogular.plugins.overlayplay\", [])\n\t.directive(\n\t\"vgOverlayPlay\",\n\t[\"VG_STATES\", function (VG_STATES) {\n\t\treturn {\n\t\t\trestrict: \"E\",\n\t\t\trequire: \"^videogular\",\n\t\t\ttemplate: \"<div class='overlayPlayContainer' ng-click='onClickOverlayPlay()'>\" +\n\t\t\t\t\"<div class='iconButton' ng-class='overlayPlayIcon'></div>\" +\n\t\t\t\t\"</div>\",\n\t\t\tlink: function (scope, elem, attr, API) {\n\t\t\t\tfunction onComplete(target, params) {\n\t\t\t\t\tscope.overlayPlayIcon = {play: true};\n\t\t\t\t}\n\n\t\t\t\tfunction onPlay(target, params) {\n\t\t\t\t\tscope.overlayPlayIcon = {};\n\t\t\t\t}\n\n\t\t\t\tfunction onChangeState(newState) {\n\t\t\t\t\tswitch (newState) {\n\t\t\t\t\t\tcase VG_STATES.PLAY:\n\t\t\t\t\t\t\tscope.overlayPlayIcon = {};\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase VG_STATES.PAUSE:\n\t\t\t\t\t\t\tscope.overlayPlayIcon = {play: true};\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase VG_STATES.STOP:\n\t\t\t\t\t\t\tscope.overlayPlayIcon = {play: true};\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tscope.onClickOverlayPlay = function onClickOverlayPlay(event) {\n\t\t\t\t\tAPI.playPause();\n\t\t\t\t};\n\n\t\t\t\tscope.overlayPlayIcon = {play: true};\n\n\t\t\t\tscope.$watch(\n\t\t\t\t\tfunction () {\n\t\t\t\t\t\treturn API.currentState;\n\t\t\t\t\t},\n\t\t\t\t\tfunction (newVal, oldVal) {\n\t\t\t\t\t\tif (newVal != oldVal) {\n\t\t\t\t\t\t\tonChangeState(newVal);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\t]);\n\n\ndefine(\"videogular-overlay-play\", function(){});\n\n",
    "/**\n * @license Videogular v0.6.3 http://videogular.com\n * Two Fucking Developers http://twofuckingdevelopers.com\n * License: MIT\n */\n/**\n * @ngdoc directive\n * @name com.2fdevs.videogular.plugins.poster:vgPoster\n * @restrict E\n * @description\n * Shows an image when player hasn't been played or has been completed a video.\n *\n * @param {string} vgUrl String with a scope name variable. URL to an image supported by the img tag.\n * **This parameter is required.**\n *\n * ```html\n * <videogular vg-theme=\"config.theme.url\" vg-autoplay=\"config.autoPlay\">\n *    <vg-video vg-src=\"sources\"></vg-video>\n *\n *    <vg-poster-image vg-url='config.plugins.poster.url'></vg-poster-image>\n * </videogular>\n * ```\n *\n */\n\"use strict\";\nangular.module(\"com.2fdevs.videogular.plugins.poster\", [])\n\t.directive(\n\t\"vgPosterImage\",\n\t[\"VG_STATES\", function (VG_STATES) {\n\t\treturn {\n\t\t\trestrict: \"E\",\n\t\t\trequire: \"^videogular\",\n\t\t\tscope: {\n\t\t\t\tvgUrl: \"=\"\n\t\t\t},\n\t\t\ttemplate: '<img ng-src=\"{{vgUrl}}\">',\n\t\t\tlink: function (scope, elem, attr, API) {\n\t\t\t\tfunction onUpdateState(newState) {\n\t\t\t\t\tswitch (newState) {\n\t\t\t\t\t\tcase VG_STATES.PLAY:\n\t\t\t\t\t\t\telem.css(\"display\", \"none\");\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase VG_STATES.STOP:\n\t\t\t\t\t\t\telem.css(\"display\", \"block\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tscope.$watch(\n\t\t\t\t\tfunction () {\n\t\t\t\t\t\treturn API.currentState;\n\t\t\t\t\t},\n\t\t\t\t\tfunction (newVal, oldVal) {\n\t\t\t\t\t\tif (newVal != oldVal) {\n\t\t\t\t\t\t\tonUpdateState(newVal);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\t]);\n\ndefine(\"videogular-poster\", function(){});\n\n",
    "define(\n    'ui/module',[\n        'views',\n        'angular-sanitize',\n        'videogular',\n        'videogular-buffering',\n        'videogular-controls',\n        'videogular-overlay-play',\n        'videogular-poster'\n    ],\n    function (views) {\n        var module = angular\n            .module('jp.angular.ui', [\n                'ngSanitize',\n                'com.2fdevs.videogular',\n                'com.2fdevs.videogular.plugins.controls',\n                'com.2fdevs.videogular.plugins.overlayplay',\n                'com.2fdevs.videogular.plugins.buffering',\n                'com.2fdevs.videogular.plugins.poster'\n            ])\n            .run(['$templateCache', views.init]);\n        return module;\n    }\n);\n",
    "define(\n    'ui/hamburger-menu/hamburger-menu',[\n        'ui/module'\n    ],\n    function defineHamburgerMenu(module) {\n        module.controller('HamburgerMenuController', [\n            function defineHamburgerMenuController() {\n                \n            }\n        ]);\n\n        return module.directive('jpHamburgerMenu', [\n            function defineHamburgerMenuDirective() {\n                return {\n                    restrict: 'AE',\n                    templateUrl: 'ui/hamburger-menu/hamburger-menu.html',\n                    controller: 'HamburgerMenuController'\n                }\n            }\n        ]);\n    }\n);\n",
    "define(\n    'ui/video-player/video-player',[\n        'ui/module'\n    ],\n    function defineVideoPlayer(module) {\n        module.controller('VideoPlayerController', [\n            '$scope',\n            '$sce',\n            function defineVideoPlayerController($scope, $sce) {\n                $scope.config = {\n                    sources: [\n                        {src: $sce.trustAsResourceUrl(\"http://static.videogular.com/assets/videos/videogular.mp4\"), type: \"video/mp4\"},\n                        {src: $sce.trustAsResourceUrl(\"http://static.videogular.com/assets/videos/videogular.webm\"), type: \"video/webm\"},\n                        {src: $sce.trustAsResourceUrl(\"http://static.videogular.com/assets/videos/videogular.ogg\"), type: \"video/ogg\"}\n                    ],\n                    tracks: [\n                        {\n                            src: \"http://www.videogular.com/assets/subs/pale-blue-dot.vtt\",\n                            kind: \"subtitles\",\n                            srclang: \"en\",\n                            label: \"English\",\n                            default: \"\"\n                        }\n                    ],\n                    plugins: {\n                        poster: \"http://www.videogular.com/assets/images/videogular.png\"\n                    }\n                };\n            }\n        ]);\n        return module.directive('jpVideoPlayer', [\n            function defineVideoPlayerDirective() {\n                return {\n                    restrict: 'AE',\n                    templateUrl: 'ui/video-player/video-player.html',\n                    controller: 'VideoPlayerController'\n                }\n            }\n        ]);\n    }\n);\n",
    "define(\n    'jp-angular-ui',[\n        'ui/hamburger-menu/hamburger-menu',\n        'ui/video-player/video-player'\n    ],\n    function defineBuild() {\n        return true;\n    }\n);\n\n"
  ]
}